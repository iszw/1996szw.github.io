<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Data Structures and Algorithms For Javascript]]></title>
    <url>%2F2019%2F09%2F24%2FData%20Structures%20and%20Algorithms%20For%20Javascript%2F</url>
    <content type="text"><![CDATA[leetcode刷题 Data StructuresString字符串反转 1234567891011121314151617181920212223242526272829303132export default (str) =&gt; &#123; // 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序 let arr = str.split(' ') // 对数组进行遍历，然后每个元素进行反转 let result = arr.map(item =&gt; &#123; return item.split('').reverse().join('') &#125;) return result.join(' ')&#125;export default (str) =&gt; &#123; // 1. 字符串按空格进行分隔，保存数组，数组的元素的先后顺序就是单词的顺序 // 2. 对数组进行遍历，然后每个元素进行反转 return str.split(' ').map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ')&#125;export default (str) =&gt; &#123; return str.split(/\s/g).map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ')&#125;/** * 对输入进行了限制（空）单词用空格隔开（没见过单词中有&lt;等特殊字符之前考虑的是空格，单引号）(LeetCode测试用例) */export default (str) =&gt; &#123; return str.length ? str.match(/[\S]+/g).map(item =&gt; &#123; return item.split('').reverse().join('') &#125;).join(' ') : ''&#125; API：String.prototype.splitString.prototype.matchArray.prototype.mapArray.prototype.reverseArray.prototype.join 计数二进制子串 难度稍大的算法题目如何解？算法的本质是寻找规律并实现 如何找到规律？发现输入和输出之间的关系，寻找突破点 复杂的实现怎么办实现是程序+数据结构的结合体 123456789101112131415161718192021222324// 关于 LeetCode 测试用例字符串过长导致 RegExp too big的问题暂时不予修复export default (str) =&gt; &#123; // 建立数据结构，堆栈，保存数据 let r = [] // 给定任意子输入都返回第一个符合条件的子串 let match = (str) =&gt; &#123; let j = str.match(/^(0+|1+)/)[0] let o = (j[0] ^ 1).toString().repeat(j.length) let reg = new RegExp(`^($&#123;j&#125;$&#123;o&#125;)`) if (reg.test(str)) &#123; return RegExp.$1 &#125; else &#123; return '' &#125; &#125; // 通过for循环控制程序运行的流程 for (let i = 0, len = str.length - 1; i &lt; len; i++) &#123; let sub = match(str.slice(i)) if (sub) &#123; r.push(sub) &#125; &#125; return r&#125; 数组正则排序递归数据结构栈堆队列链表矩阵二叉树常见算法贪心算法动态规划]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>leetcode</tag>
        <tag>coding</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortcut Key For VS Code]]></title>
    <url>%2F2019%2F01%2F11%2FShortcut%20Key%20For%20VS%20Code%2F</url>
    <content type="text"><![CDATA[Shortcut Key For VS Code 全局Command + Shift + P / F1 显示命令面板Command + P 快速打开Command + Shift + N 打开新窗口Command + W 关闭窗口 基本Command + X 剪切（未选中文本的情况下，剪切光标所在行）Command + C 复制（未选中文本的情况下，复制光标所在行）Option + Up 向上移动行Option + Down 向下移动行Option + Shift + Up 向上复制行Option + Shift + Down 向下复制行Command + Shift + K 删除行Command + Enter 下一行插入Command + Shift + Enter 上一行插入Command + Shift + \ 跳转到匹配的括号Command + [ 减少缩进Command + ] 增加缩进Home 跳转至行首End 跳转到行尾Command + Up 跳转至文件开头Command + Down 跳转至文件结尾Ctrl + PgUp 按行向上滚动Ctrl + PgDown 按行向下滚动Command + PgUp 按屏向上滚动Command + PgDown 按屏向下滚动Command + Shift + [ 折叠代码块Command + Shift + ] 展开代码块Command + K Command + [ 折叠全部子代码块Command + K Command + ] 展开全部子代码块Command + K Command + 0 折叠全部代码块Command + K Command + J 展开全部代码块Command + K Command + C 添加行注释Command + K Command + U 移除行注释Command + / 添加、移除行注释Option + Shift + A 添加、移除块注释Option + Z 自动换行、取消自动换行 多光标与选择Option + 点击 插入多个光标Command + Option + Up 向上插入光标Command + Option + Down 向下插入光标Command + U 撤销上一个光标操作Option + Shift + I 在所选行的行尾插入光标Command + I 选中当前行Command + Shift + L 选中所有与当前选中内容相同部分Command + F2 选中所有与当前选中单词相同的单词Command + Ctrl + Shift + Left 折叠选中Command + Ctrl + Shift + Right 展开选中Alt + Shift + 拖动鼠标 选中代码块Command + Shift + Option + Up 列选择 向上Command + Shift + Option + Down 列选择 向下Command + Shift + Option + Left 列选择 向左Command + Shift + Option + Right 列选择 向右Command + Shift + Option + PgUp 列选择 向上翻页Command + Shift + Option + PgDown 列选择 向下翻页 查找替换Command + F 查找Command + Option + F 替换Command + G 查找下一个Command + Shift + G 查找上一个Option + Enter 选中所有匹配项Command + D 向下选中相同内容Command + K Command + D 移除前一个向下选中相同内容 进阶Ctrl + Space 打开建议Command + Shift + Space 参数提示Tab Emmet插件缩写补全Option + Shift + F 格式化Command + K Command + F 格式化选中内容F12 跳转到声明位置Option + F12 查看具体声明内容Command + K F12 分屏查看具体声明内容Command + . 快速修复Shift + F12 显示引用F2 重命名符号Command + Shift + . 替换为上一个值Command + Shift + , 替换为下一个值Command + K Command + X 删除行尾多余空格Command + K M 更改文件语言 导航Command + T 显示所有符号Ctrl + G 跳转至某行Command + P 跳转到某个文件Command + Shift + O 跳转到某个符号Command + Shift + M 打开问题面板F8 下一个错误或警告位置Shift + F8 上一个错误或警告位置Ctrl + Shift + Tab 编辑器历史记录Ctrl + - 后退Ctrl + Shift + - 前进Ctrl + Shift + M Tab 切换焦点 编辑器管理Command + W 关闭编辑器Command + K F 关闭文件夹Command + \ 编辑器分屏Command + 1 切换到第一分组Command + 2 切换到第二分组Command + 3 切换到第三分组Command + K Command + Left 切换到上一分组Command + K Command + Right 切换到下一分组Command + K Command + Shift + Left 左移编辑器Command + K Command + Shift + Right 右移编辑器Command + K Left 激活左侧编辑组Command + K Right 激活右侧编辑组 文件管理Command + N 新建文件Command + O 打开文件Command + S 保存文件Command + Shift + S 另存为Command + Option + S 全部保存Command + W 关闭Command + K Command + W 全部关闭Command + Shift + T 重新打开被关闭的编辑器Command + K Enter 保持打开Ctrl + Tab 打开下一个Ctrl + Shift + Tab 打开上一个Command + K P 复制当前文件路径Command + K R 在资源管理器中查看当前文件Command + K O 新窗口打开当前文件 显示Command + Ctrl + F 全屏、退出全屏Command + Option + 1 切换编辑器分屏方式（横、竖）Command + + 放大Command + - 缩小Command + B 显示、隐藏侧边栏Command + Shift + E 显示资源管理器 或 切换焦点Command + Shift + F 显示搜索框Ctrl + Shift + G 显示Git面板Command + Shift + D 显示调试面板Command + Shift + X 显示插件面板Command + Shift + H 全局搜索替换Command + Shift + J 显示、隐藏高级搜索Command + Shift + C 打开新终端Command + Shift + U 显示输出面板Command + Shift + V Markdown预览窗口Command + K V 分屏显示 Markdown预览窗口 调试F9 设置 或 取消断点F5 开始 或 继续F11 进入Shift + F11 跳出F10 跳过Command + K Command + I 显示悬停信息 集成终端Ctrl + 显示终端 Ctrl + Shift + 新建终端Command + Up 向上滚动Command + Down 向下滚动PgUp 向上翻页PgDown 向下翻页Command + Home 滚动到顶部Command + End 滚动到底部]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0搭建旅游网站开发笔记]]></title>
    <url>%2F2018%2F03%2F14%2FVue2.0%E6%90%AD%E5%BB%BA%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Info: Vue开发旅游网站笔记整理 前言这是最近使用Vue写的仿去哪儿网旅游网站，大致实现了网站首页Header制作、首页轮播、图标区块、热销推荐、使用axios获取接口数据、首页父子组件间的传递、城市选择页面路由配置、搜索框布局、better-scroll的使用及字母表布局、搜索的逻辑实现、Vuex实现数据共享、LocalStorage实现页面数据持久存储、使用keep-alive优化路由页面性能、动态路由配置及banner布局、公用画廊组件的拆分、渐隐渐显的header效果实现、递归组件实现详情列表、画廊动画效果封装等实用性网站功能。 在此要十分感谢Vue框架的作者Evan You，这种渐进式的开发方式的确十分的友好，也让人深刻地领会到组件化开发所带来的便捷之处。 而本篇文章是作为整个项目开发时的一些记录，以便日后完善或者重构代码时能够更加清晰。 项目源码：https://github.com/1996szw/TravelWeb 使用方式： 1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report 项目代码初始化配置移动端的&lt;meta&gt;标签12&lt;!-- 设置移动端屏幕比例不可缩放 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; 引入reset.css在不同的移动设备上，浏览器的初始样式表是不统一的。所以需要引入reset.css来进行统一化，之后在项目入口文件main.js中引用该样式表：import &#39;styles/reset.css&#39; 1234567891011121314151617181920212223242526/* 重置样式表reset.css */@charset "utf-8";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,"Hiragino Sans GB",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,"Hiragino Sans GB","微软雅黑",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:"\0020"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, "Microsoft Yahei", "Helvetica Neue", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125; 解决移动设备中的一像素边框问题有的移动设备分辨率比较高是一个二倍屏或是三倍屏，所以在写1像素边框的时候，写的是1px但实际渲染出来却是2px或是3px。所以需要引入一个1像素边框的解决方案:import &#39;styles/border.css&#39; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/* 1像素边框的解决方案border.css *//* 该代码解决方式是css中的scale */@charset "utf-8";.border,.border-top,.border-right,.border-bottom,.border-left,.border-topbottom,.border-rightleft,.border-topleft,.border-rightbottom,.border-topright,.border-bottomleft &#123; position: relative;&#125;.border::before,.border-top::before,.border-right::before,.border-bottom::before,.border-left::before,.border-topbottom::before,.border-topbottom::after,.border-rightleft::before,.border-rightleft::after,.border-topleft::before,.border-topleft::after,.border-rightbottom::before,.border-rightbottom::after,.border-topright::before,.border-topright::after,.border-bottomleft::before,.border-bottomleft::after &#123; content: "\0020"; overflow: hidden; position: absolute;&#125;/* border * 因，边框是由伪元素区域遮盖在父级 * 故，子级若有交互，需要对子级设置 * 定位 及 z轴 */.border::before &#123; box-sizing: border-box; top: 0; left: 0; height: 100%; width: 100%; border: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-bottom::before,.border-topbottom::before,.border-topbottom::after,.border-topleft::before,.border-rightbottom::after,.border-topright::before,.border-bottomleft::before &#123; left: 0; width: 100%; height: 1px;&#125;.border-right::before,.border-left::before,.border-rightleft::before,.border-rightleft::after,.border-topleft::after,.border-rightbottom::before,.border-topright::after,.border-bottomleft::after &#123; top: 0; width: 1px; height: 100%;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; border-top: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-right::before,.border-rightbottom::before,.border-rightleft::before,.border-topright::after &#123; border-right: 1px solid #eaeaea; transform-origin: 100% 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::before &#123; border-bottom: 1px solid #eaeaea; transform-origin: 0 100%;&#125;.border-left::before,.border-topleft::after,.border-rightleft::after,.border-bottomleft::after &#123; border-left: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; top: 0;&#125;.border-right::before,.border-rightleft::after,.border-rightbottom::before,.border-topright::after &#123; right: 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::after &#123; bottom: 0;&#125;.border-left::before,.border-rightleft::before,.border-topleft::after,.border-bottomleft::before &#123; left: 0;&#125;@media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) &#123; /* 默认值，无需重置 */&#125;@media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) &#123; .border::before &#123; width: 200%; height: 200%; transform: scale(.5); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.5); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.5); &#125;&#125;@media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) &#123; .border::before &#123; width: 300%; height: 300%; transform: scale(.33333); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.33333); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.33333); &#125;&#125; 解决移动端的点击300ms延时的问题在项目中，尤其是移动项目中在某些机型、某些浏览器上使用click事件的时候，这些click事件会延迟300ms才会执行，导致用户体验不佳，所以需要引入fastclick第三方库:npm install fastclick --save，然后在main.js中引用并使用这个库: 123import fastClick from 'fastclick'fastClick.attach(document.body) 网站首页的开发移动项目的开发中使用rem如果设计师给的是二倍屏中的86像素，对应就是一倍屏中的43像素，而reset.css中将html{font-size: 50px}，那么就有：1rem = html font size = 50px。所以43px = .86rem 使用css预处理器stylus中的贯穿式变量如果在样式中某一个颜色代码或者尺寸数字会被经常使用到，那么可以在styles文件夹下写一个varibles.styl文件专门用来存放这些个变量，然后在对应的css中引用：@import &#39;../../../assets/styles/varilbes.styl&#39;。这样写引用太复杂了，所以可以在webpack.base.conf.js中将styles目录设置一个别名: 123456789resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'styles': resolve('src/assets/styles'), 'common': resolve('src/common') &#125; &#125;, 使用占位来解决图片还未加载时候高度为0之后会有一个抖动的问题给该图片区域包裹一层&lt;div&gt;标签，然后设置该区块的宽度为100%，而它的高度会根据宽度自动地撑开31.25%: 12345.wrapper overflow hidden width 100% height 0 padding-bottom 31.25% css中的样式穿透当需要设置scoped外其它组件中的元素样式时，需要使用&gt;&gt;&gt;来进行一个样式穿透: 12.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background #fff 使用vue-awesome-swiper来显示icon轮播效果时翻页的算法1234567891011121314// 借助computed计算属性computed: &#123; pages () &#123; const pages = [] this.iconList.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8) if (!pages[page]) &#123; pages[page] = [] &#125; pages[page].push(item) &#125;) return pages &#125; &#125; 使用css预处理器stylus中的混合书写Mixins提供…占位符来表示由于空间不够而被隐藏的内容，可以使用stylus中将该方法封装成mixins.styl，然后在需要的地方调用：ellipsis() 1234ellipsis() overflow hidden white-space nowrap text-overflow ellipsis 在vue中使用axios1234567891011121314151617181920212223242526import axios from 'axios'methods: &#123; getHomeInfo () &#123; axios.get('/api/index.json?city=' + this.city) .then(this.getHomeInfoSucc) // axios返回的是一个promise对象，所以可以调用.then方法 &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.weekendList &#125; &#125;&#125;mounted () &#123; this.getHomeInfo()&#125;activated () &#123; this.getHomeInfo()&#125; 城市选择页面开发better-scroll的使用better-scroll是iscroll的一个封装，使用起来要更为友好。若要使用这个包，先要用npm安装:npm install better-scroll --save。然后html代码需要符合如下结构： 12345678&lt;div class="wrapper"&gt; &lt;ul class="content"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won't affect the scrolling --&gt;&lt;/div&gt; 在上面的代码中，better-scroll应用于外部wrapper容器，滚动部分是content元素。注意，better-scroll只处理容器（wrapper）的第一个子元素（内容）的滚动，这意味着将忽略其他元素。最简单的初始化代码如下： 1234import BScroll from 'beetter-scroll'const wrapper = document.querySelector('wrapper')const scroll = new BScorll(wrapper) better-scroll提供了一个类，其实例化时其第一个参数是普通DOM对象。当然，better-scroll内部会尝试使用querySelector来获取DOM对象，因此initiazation代码也可以如下所示： 123import BScroll from 'better-scroll'const scroll = new BScroll('.wrapper') 获取拖拽动作最后得到的内容并做一个函数节流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class="list"&gt; &lt;ul&gt; &lt;li class="item" v-for="item of letters" :key="item" :ref="item" @click="handleLetterClick" @touchstart.prevent="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd" &gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'CityAlphabet', props: &#123; cities: Object &#125;, data () &#123; return &#123; touchStatus: false, startY: 0, timer: null &#125; &#125;, updated () &#123; this.startY = this.$refs['A'][0].offsetTop &#125;, computed: &#123; letters () &#123; const letters = [] for (let i in this.cities) &#123; letters.push(i) &#125; return letters &#125; &#125;, methods: &#123; handleLetterClick (e) &#123; this.$emit('change', e.target.innerText) &#125;, handleTouchStart () &#123; this.touchStatus = true &#125;, handleTouchMove (e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; // 函数节流 clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; const touchY = e.touches[0].clientY - 75 const index = Math.floor((touchY - this.startY) / 18) if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]) &#125; &#125;, 16) &#125; &#125;, handleTouchEnd () &#123; this.touchStatus = false &#125; &#125;&#125;&lt;/script&gt; 使用vuex来实现数据共享Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。在Vue的大型项目开发之中，Vue.js只能承担视图层的主要内容，而当涉及到大量数据间的传递，往往都要通过vuex这个数据框架来完成。虽然bus总线的作法有时候也可以完成效果，但写起来还是比较麻烦。 Vuex其实就是一个单向数据的改变流程。使用vuex需要先安装vuex：npm install vuex --save，之后要在项目的入口文件main.js中引入这个包并在创建根实例的时候把store传递进去来使用： 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: '杭州' &#125;, actions: &#123; changeCity (ctx, city) &#123; // ctx是一个上下文，可以通过它来执行commit方法 ctx.commit('changeCity', city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city &#125; &#125;,&#125;) vuex中的map映射api在每次调用vuex公用数据中的city的时候，都要写this.$store.state.city这样的一串，而vuex就提供了一个map映射api来简化这样的代码，先要引入需要映射的数据，然后通过...扩展运算符将state里面的city映射到HomeHeader这个组件的computed计算属性中，然后就可以直接通过this.city来调用这个数据了(如果是mutations则可以映射到组件的methods方法中) 12345678import &#123; mapState &#125; from 'vuex'export default &#123; name: 'HomeHeader', computed: &#123; ...mapState(['city']) &#125;&#125; vuex中的getter和modulevuex中的getter很类似于组件中的computed计算属性，如果需要根据vuex的state里的数据来计算出一个新的数据的时候，就可以通过getter来进行实现，从而避免数据的冗余。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB &#x3D; &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store &#x3D; new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a &#x2F;&#x2F; -&gt; moduleA 的状态store.state.b &#x2F;&#x2F; -&gt; moduleB 的状态 vue中的内置组件&lt;keep-alive&gt;&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和&lt;transition&gt;相似，&lt;keep-alive&gt;是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中。 &lt;keep-alive&gt;可以接受可选参数： include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 当组件在&lt;keep-alive&gt;内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 123456789101112131415methods: &#123; getDetailInfo () &#123; axios.get('/api/detail.json', &#123; params: &#123; id: this.$route.params.id &#125; &#125;).then(this.handleGetDataSucc) &#125;&#125; mounted () &#123; this.getDetailInfo() &#125;, activated () &#123; this.getDetailInfo() // 每次页面被加载的时候，都重新发送一个ajax请求 &#125; 详情页面的开发动态路由&lt;router-link&gt;标签的to前面可以跟一个:来作一个动态路由，这样就可以传递出一个参数给router。调用这个参数可以通过this.$router.params.id 12345678910111213141516&lt;ul&gt; &lt;router-link tag="li" class="item border-bottom" v-for="item of recommendList" :key="item.id" :to="'/detail/' + item.id" &gt; &lt;img class="item-img" :src="item.imgUrl" /&gt; &lt;div class="item-info"&gt; &lt;p class="item-title"&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;p class="item-desc"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt; &lt;button class="item-btn"&gt;查看详情&lt;/button&gt; &lt;/div&gt; &lt;/router-link&gt;&lt;/ul&gt; 给DOM元素添加一个渐变的边框12.banner-info background-image linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, .5)) 实现顶部Header区域拖动渐隐渐现效果如果通过给window对象绑定一个全局事件的方式来实现某个功能，那么要记得及时地对这个全局事件进行一个解绑，否则就会影响外部组件。 12345678910111213141516171819202122232425262728name: 'DetailHeader',data () &#123; return &#123; showAbs: true, opacityStyle: &#123; opacity: 0 &#125; &#125;&#125;,methods: &#123; handleScroll () &#123; const top = document.documentElement.scrollTop if (top &gt; 60) &#123; let countOpacity = top / 140 countOpacity = countOpacity &gt; 1 ? 1 : countOpacity this.opacityStyle.opacity = countOpacity this.showAbs = false &#125; else &#123; this.showAbs = true &#125; &#125;&#125;,activated () &#123; window.addEventListener('scroll', this.handleScroll)&#125;,deactivated () &#123; // 使用deactivated来对全局事件进行解绑，当退出这个页面时，此函数会被执行 window.removeEventListener('scroll', this.handleScroll)&#125; 递归组件在组件模板中调用组件的自身就叫做递归组件。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;div class="item" v-for="(item, index) of list" :key="index"&gt; &lt;div class="item-title border-bottom"&gt; &lt;span class="item-title-icon"&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if="item.children" class="item-children"&gt; &lt;detail-list :list="item.children"&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'DetailList', data: &#123; list: [ &#123; title: '我是一级标题', children: [&#123; title: '我是二级标题', children: [&#123; title: '我是三级标题' &#125;] &#125;] &#125;, &#123; title: '我是一级标题', children: [ &#123; title: '我是二级标题' &#125; ] &#125;, &#123; title: '我是一级标题' &#125; ]&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>travelweb</tag>
        <tag>vue-awesome-swiper</tag>
        <tag>axios</tag>
        <tag>better-scroll</tag>
        <tag>vuex</tag>
        <tag>localstorge</tag>
        <tag>keep-alive</tag>
        <tag>vue-router</tag>
        <tag>动态路由</tag>
        <tag>父子组件间传递数据</tag>
        <tag>递归组建</tag>
        <tag>移动开发</tag>
        <tag>reset.css</tag>
        <tag>1像素边框</tag>
        <tag>300ms点击延时</tag>
        <tag>rem</tag>
        <tag>stylus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【毕设】数据挖掘算法之Apriori关联规则挖掘]]></title>
    <url>%2F2018%2F01%2F12%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95%E4%B9%8BApriori%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[Info: Apriori关联规则算法学习 关联分析关联分析是一种在大规模数据集中寻找有趣关系的任务。这些关系可以有两种形式: 频繁项集（frequent item sets）: 经常出现在一块的物品的集合。 关联规则（associational rules）: 暗示两种物品之间可能存在很强的关系。 相关术语 关联分析（关联规则学习): 从大规模数据集中寻找物品间的隐含关系被称作 关联分析(associati analysis) 或者 关联规则学习（association rule learning） 。 下面是用一个 杂货店 例子来说明这两个概念，如下图所示: 频繁项集: {葡萄酒, 尿布, 豆奶} 就是一个频繁项集的例子。 关联规则: 尿布 -&gt; 葡萄酒 就是一个关联规则。这意味着如果顾客买了尿布，那么他很可能会买葡萄酒。 那么 频繁 的定义是什么呢？怎么样才算频繁呢？度量它们的方法有很多种，这里我们来简单的介绍下支持度和置信度。 支持度: 数据集中包含该项集的记录所占的比例。例如上图中，{豆奶} 的支持度为 4/5。{豆奶, 尿布} 的支持度为 3/5。 置信度: 针对一条诸如 {尿布} -&gt; {葡萄酒} 这样具体的关联规则来定义的。这条规则的 置信度 被定义为 支持度({尿布, 葡萄酒})/支持度({尿布})，从图中可以看出 支持度({尿布, 葡萄酒}) = 3/5，支持度({尿布}) = 4/5，所以 {尿布} -&gt; {葡萄酒} 的置信度 = 3/5 / 4/5 = 3/4 = 0.75。 支持度 和 置信度 是用来量化 关联分析 是否成功的一个方法。假设想找到支持度大于 0.8 的所有项集，应该如何去做呢？一个办法是生成一个物品所有可能组合的清单，然后对每一种组合统计它出现的频繁程度，但是当物品成千上万时，上述做法就非常非常慢了。我们需要详细分析下这种情况并讨论下 Apriori 原理，该原理会减少关联规则学习时所需的计算量。 Apriori 原理假设我们一共有 4 个商品: 商品0, 商品1, 商品2, 商品3。所有可能的情况如下:如果我们计算所有组合的支持度，也需要计算 15 次。即 2^N - 1 = 2^4 - 1 = 15。随着物品的增加，计算的次数呈指数的形式增长 … 为了降低计算次数和时间，研究人员发现了一种所谓的 Apriori 原理，即某个项集是频繁的，那么它的所有子集也是频繁的。例如，如果 {0, 1} 是频繁的，那么 {0}, {1} 也是频繁的。 该原理直观上没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是 非频繁项集，那么它的所有超集也是非频繁项集，如下图所示: 在图中我们可以看到，已知灰色部分 {2,3} 是 非频繁项集，那么利用上面的知识，我们就可以知道 {0,2,3} {1,2,3} {0,1,2,3} 都是 非频繁的。也就是说，计算出 {2,3} 的支持度，知道它是 非频繁 的之后，就不需要再计算 {0,2,3} {1,2,3} {0,1,2,3} 的支持度，因为我们知道这些集合不会满足我们的要求。使用该原理就可以避免项集数目的指数增长，从而在合理的时间内计算出频繁项集。 Apriori 算法优缺点 123* 优点：易编码实现* 缺点：在大数据集上可能较慢* 适用数据类型：数值型 或者标准型数据。 Apriori 算法流程步骤： 123456* 收集数据：使用任意方法。* 准备数据：任何数据类型都可以，因为我们只保存集合。* 分析数据：使用任意方法。* 训练数据：使用Apiori算法来找到频繁项集。* 测试算法：不需要测试过程。* 使用算法：用于发现频繁项集以及物品之间的关联规则。 Apriori 算法的使用前面提到，关联分析的目标包括两项: 发现 频繁项集 和发现 关联规则。首先需要找到 频繁项集，然后才能发现 关联规则。Apriori 算法是发现 频繁项集 的一种方法。Apriori 算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个物品的项集列表。接着扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度要求的集合会被去掉。然后对生下来的集合进行组合以生成包含两个元素的项集。接下来再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集被去掉。 生成候选项集下面会创建一个用于构建初始集合的函数，也会创建一个通过扫描数据集以寻找交易记录子集的函数，数据扫描的伪代码如下: 对数据集中的每条交易记录 tran 对每个候选项集 can 检查一下 can 是否是 tran 的子集: 如果是则增加 can 的计数值 对每个候选项集 can 如果其支持度不低于最小值，则保留该项集 返回所有频繁项集列表 以下是一些辅助函数。 加载数据集123# 加载数据集def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]] 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset1234567891011121314151617181920212223# 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozensetdef createC1(dataSet): """createC1（创建集合 C1） Args: dataSet 原始数据集 Returns: frozenset 返回一个 frozenset 格式的 list """ C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: # 遍历所有的元素，如果不在 C1 出现过，那么就 append C1.append([item]) # 对数组进行 `从小到大` 的排序 print 'sort 前=', C1 C1.sort() # frozenset 表示冻结的 set 集合，元素无改变；可以把它当字典的 key 来使用 print 'sort 后=', C1 print 'frozenset=', map(frozenset, C1) return map(frozenset, C1) 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据1234567891011121314151617181920212223242526272829303132333435# 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据def scanD(D, Ck, minSupport): """scanD（计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度 minSupport 的数据） Args: D 数据集 Ck 候选项集列表 minSupport 最小支持度 Returns: retList 支持度大于 minSupport 的集合 supportData 候选项集支持度数据 """ # ssCnt 临时存放选数据集 Ck 的频率. 例如: a-&gt;10, b-&gt;5, c-&gt;8 ssCnt = &#123;&#125; for tid in D: for can in Ck: # s.issubset(t) 测试是否 s 中的每一个元素都在 t 中 if can.issubset(tid): if not ssCnt.has_key(can): ssCnt[can] = 1 else: ssCnt[can] += 1 numItems = float(len(D)) # 数据集 D 的数量 retList = [] supportData = &#123;&#125; for key in ssCnt: # 支持度 = 候选项（key）出现的次数 / 所有数据集的数量 support = ssCnt[key]/numItems if support &gt;= minSupport: # 在 retList 的首位插入元素，只存储支持度满足频繁项集的值 retList.insert(0, key) # 存储所有的候选项（key）和对应的支持度（support） supportData[key] = support return retList, supportData 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 组织完整的 Apriori 算法输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ck12345678910111213141516171819202122232425262728293031# 输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ckdef aprioriGen(Lk, k): """aprioriGen（输入频繁项集列表 Lk 与返回的元素个数 k，然后输出候选项集 Ck。 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; 仅需要计算一次，不需要将所有的结果计算出来，然后进行去重操作 这是一个更高效的算法） Args: Lk 频繁项集列表 k 返回的项集元素个数（若元素的前 k-2 相同，就进行合并） Returns: retList 元素两两合并的数据集 """ retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[: k-2] L2 = list(Lk[j])[: k-2] # print '-----i=', i, k-2, Lk, Lk[i], list(Lk[i])[: k-2] # print '-----j=', j, k-2, Lk, Lk[j], list(Lk[j])[: k-2] L1.sort() L2.sort() # 第一次 L1,L2 为空，元素直接进行合并，返回元素两两合并的数据集 # if first k-2 elements are equal if L1 == L2: # set union # print 'union=', Lk[i] | Lk[j], Lk[i], Lk[j] retList.append(Lk[i] | Lk[j]) return retList 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。1234567891011121314151617181920212223242526272829303132333435363738394041# 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。def apriori(dataSet, minSupport=0.5): """apriori（首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，C2 再进一步过滤变成 L2，然后以此类推，知道 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。） Args: dataSet 原始数据集 minSupport 支持度的阈值 Returns: L 频繁项集的全集 supportData 所有元素和支持度的全集 """ # C1 即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset C1 = createC1(dataSet) # 对每一行进行 set 转换，然后存放到集合中 D = map(set, dataSet) print 'D=', D # 计算候选数据集 C1 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 L1, supportData = scanD(D, C1, minSupport) # print "L1=", L1, "\n", "outcome: ", supportData # L 加了一层 list, L 一共 2 层 list L = [L1] k = 2 # 判断 L 的第 k-2 项的数据长度是否 &gt; 0。第一次执行时 L 为 [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]]。L[k-2]=L[0]=[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]，最后面 k += 1 while (len(L[k-2]) &gt; 0): print 'k=', k, L, L[k-2] Ck = aprioriGen(L[k-2], k) # 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; print 'Ck', Ck Lk, supK = scanD(D, Ck, minSupport) # 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 # 保存所有候选项集的支持度，如果字典没有，就追加元素，如果有，就更新元素 supportData.update(supK) if len(Lk) == 0: break # Lk 表示满足频繁子项的集合，L 元素在增加，例如: # l=[[set(1), set(2), set(3)]] # l=[[set(1), set(2), set(3)], [set(1, 2), set(2, 3)]] L.append(Lk) k += 1 # print 'k=', k, len(L[k-2]) return L, supportData 到这一步，我们就找出我们所需要的 频繁项集 和他们的 支持度 了，接下来再找出关联规则即可！ 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 从频繁项集中挖掘关联规则前面我们介绍了用于发现 频繁项集 的 Apriori 算法，现在要解决的问题是如何找出 关联规则。 要找到 关联规则，我们首先从一个 频繁项集 开始。我们知道集合中的元素是不重复的，但我们想知道基于这些元素能否获得其它内容。某个元素或某个元素集合可能会推导出另一个元素。从先前 杂货店 的例子可以得到，如果有一个频繁项集 {豆奶,莴苣}，那么就可能有一条关联规则 “豆奶 -&gt; 莴苣”。这意味着如果有人买了豆奶，那么在统计上他会购买莴苣的概率比较大。但是，这一条件反过来并不总是成立。也就是说 “豆奶 -&gt; 莴苣” 统计上显著，那么 “莴苣 -&gt; 豆奶” 也不一定成立。 前面我们给出了 频繁项集 的量化定义，即它满足最小支持度要求。对于 关联规则，我们也有类似的量化方法，这种量化指标称之为 置信度。一条规则 A -&gt; B 的置信度定义为 support(A | B) / support(A)。（注意: 在 python 中 | 表示集合的并操作，而数学书集合并的符号是 U）。A | B 是指所有出现在集合 A 或者集合 B 中的元素。由于我们先前已经计算出所有 频繁项集 的支持度了，现在我们要做的只不过是提取这些数据做一次除法运算即可。 一个频繁项集可以产生多少条关联规则呢？如下图所示，给出的是项集 {0,1,2,3} 产生的所有关联规则: 与我们前面的 频繁项集 生成一样，我们可以为每个频繁项集产生许多关联规则。如果能减少规则的数目来确保问题的可解析，那么计算起来就会好很多。通过观察，我们可以知道，如果某条规则并不满足 最小置信度 要求，那么该规则的所有子集也不会满足 最小置信度 的要求。如上图所示，假设 123 -&gt; 3 并不满足最小置信度要求，那么就知道任何左部为 {0,1,2} 子集的规则也不会满足 最小置信度 的要求。即 12 -&gt; 03 , 02 -&gt; 13 , 01 -&gt; 23 , 2 -&gt; 013, 1 -&gt; 023, 0 -&gt; 123 都不满足 最小置信度 要求。 可以利用关联规则的上述性质属性来减少需要测试的规则数目，跟先前 Apriori 算法的套路一样。以下是一些辅助函数: 计算置信度1234567891011121314151617181920212223242526# 计算置信度（confidence）def calcConf(freqSet, H, supportData, brl, minConf=0.7): """calcConf（对两个元素的频繁项，计算置信度，例如： &#123;1,2&#125;/&#123;1&#125; 或者 &#123;1,2&#125;/&#123;2&#125; 看是否满足条件） Args: freqSet 频繁项集中的元素，例如: frozenset([1, 3]) H 频繁项集中的元素的集合，例如: [frozenset([1]), frozenset([3])] supportData 所有元素的支持度的字典 brl 关联规则列表的空数组 minConf 最小置信度 Returns: prunedH 记录 置信度大于阈值的集合 """ # 记录置信度大于最小置信度（minConf）的集合 prunedH = [] for conseq in H: # 假设 freqSet = frozenset([1, 3]), H = [frozenset([1]), frozenset([3])]，那么现在需要求出 frozenset([1]) -&gt; frozenset([3]) 的置信度和 frozenset([3]) -&gt; frozenset([1]) 的置信度 # print 'confData=', freqSet, H, conseq, freqSet-conseq conf = supportData[freqSet]/supportData[freqSet-conseq] # 支持度定义: a -&gt; b = support(a | b) / support(a). 假设 freqSet = frozenset([1, 3]), conseq = [frozenset([1])]，那么 frozenset([1]) 至 frozenset([3]) 的置信度为 = support(a | b) / support(a) = supportData[freqSet]/supportData[freqSet-conseq] = supportData[frozenset([1, 3])] / supportData[frozenset([1])] if conf &gt;= minConf: # 只要买了 freqSet-conseq 集合，一定会买 conseq 集合（freqSet-conseq 集合和 conseq 集合是全集） print freqSet-conseq, '--&gt;', conseq, 'conf:', conf brl.append((freqSet-conseq, conseq, conf)) prunedH.append(conseq) return prunedH 递归计算频繁项集的规则1234567891011121314151617181920212223242526272829303132# 递归计算频繁项集的规则def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): """rulesFromConseq Args: freqSet 频繁项集中的元素，例如: frozenset([2, 3, 5]) H 频繁项集中的元素的集合，例如: [frozenset([2]), frozenset([3]), frozenset([5])] supportData 所有元素的支持度的字典 brl 关联规则列表的数组 minConf 最小置信度 """ # H[0] 是 freqSet 的元素组合的第一个元素，并且 H 中所有元素的长度都一样，长度由 aprioriGen(H, m+1) 这里的 m + 1 来控制 # 该函数递归时，H[0] 的长度从 1 开始增长 1 2 3 ... # 假设 freqSet = frozenset([2, 3, 5]), H = [frozenset([2]), frozenset([3]), frozenset([5])] # 那么 m = len(H[0]) 的递归的值依次为 1 2 # 在 m = 2 时, 跳出该递归。假设再递归一次，那么 H[0] = frozenset([2, 3, 5])，freqSet = frozenset([2, 3, 5]) ，没必要再计算 freqSet 与 H[0] 的关联规则了。 m = len(H[0]) if (len(freqSet) &gt; (m + 1)): print 'freqSet******************', len(freqSet), m + 1, freqSet, H, H[0] # 生成 m+1 个长度的所有可能的 H 中的组合，假设 H = [frozenset([2]), frozenset([3]), frozenset([5])] # 第一次递归调用时生成 [frozenset([2, 3]), frozenset([2, 5]), frozenset([3, 5])] # 第二次 。。。没有第二次，递归条件判断时已经退出了 Hmp1 = aprioriGen(H, m+1) # 返回置信度大于最小置信度的集合 Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) print 'Hmp1=', Hmp1 print 'len(Hmp1)=', len(Hmp1), 'len(freqSet)=', len(freqSet) # 计算置信度后，还有数据大于最小置信度的话，那么继续递归调用，否则跳出递归 if (len(Hmp1) &gt; 1): print '----------------------', Hmp1 # print len(freqSet), len(Hmp1[0]) + 1 rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 生成关联规则12345678910111213141516171819202122232425# 生成关联规则def generateRules(L, supportData, minConf=0.7): """generateRules Args: L 频繁项集列表 supportData 频繁项集支持度的字典 minConf 最小置信度 Returns: bigRuleList 置信度规则列表（关于 (A-&gt;B+置信度) 3个字段的组合） """ bigRuleList = [] # 假设 L = [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])], [frozenset([1, 3]), frozenset([2, 5]), frozenset([2, 3]), frozenset([3, 5])], [frozenset([2, 3, 5])]] for i in range(1, len(L)): # 获取频繁项集中每个组合的所有元素 for freqSet in L[i]: # 假设：freqSet= frozenset([1, 3]), H1=[frozenset([1]), frozenset([3])] # 组合总的元素并遍历子元素，并转化为 frozenset 集合，再存放到 list 列表中 H1 = [frozenset([item]) for item in freqSet] # 2 个的组合，走 else, 2 个以上的组合，走 if if (i &gt; 1): rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList 到这里为止，通过调用 generateRules 函数即可得出我们所需的 关联规则。 分级法： 频繁项集-&gt;关联规则 1.首先从一个频繁项集开始，接着创建一个规则列表，其中规则右部分只包含一个元素，然后对这个规则进行测试。 2.接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。 如下图： 最后： 每次增加频繁项集的大小，Apriori 算法都会重新扫描整个数据集，是否有优化空间呢？ 信息参考于 ApacheCN]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
        <tag>graduation</tag>
        <tag>数据挖掘</tag>
        <tag>关联规则算法</tag>
        <tag>apriori</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【毕设】Hadoop完全分布式平台搭建]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91Hadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Info: 毕业设计课题基础Hadoop环境搭建 步入大四，毕设也是今年的重中之重，学校给我分配的课题是《基于大数据平台的关联规则算法的研究与实现》。之前没有接触过大数据的我也是要从头开始相关的学习，比如Hadoop环境的配置、关联规则算法的python实现、还有如何将Apriori算法在MapReduce上面并行化等等等等。本文就是Hadoop完全分布式平台的搭建记录。 另外也要感谢我校嵌入式研究中心的主任李超老师，给我提供了性能可靠的物理服务器来进行该课题的研究。 搭建Hadoop全分布式集群前提虚拟机软件的安装网上随便找的Vmware workstation，然后在centOS官网找个镜像装一下就OK了。但由于自己是学校给的服务器，所以略过这一步。 虚拟机的网络如果是在一台虚拟机中安装多个Linux操作系统的话，可以使用NAT或桥接模式都是可以的。 步骤： 在要使用的虚拟机的标签上右键单击，选择设置，选择网络适配器，选择桥接模式，确定。 设置完成之后，重启一下虚拟机。 再设置桥接之前将固定的IP取消： 桌面版：通过图形化界面设置的。 服务器版：在/etc/network/interfacesiface ens33 inet dhcp #address ... ifconfig获取IP。 最后试一试能不能ping通。 文件读写权限在linux下，软件安装到/opt下，当前正在使用的用户，对于opt目录需要有读写权限： 1）将opt的权限给为777（漏洞文件），不推荐在生产环境中使用。但是可以在学习和调试环境中使用。 2）sudo 在启动Hadoop的各个守护进程的时候，需要使用sudo。 在管理Hadoop的时候，实际上由不同的用户启动不同集群的守护进程。 统一使用当前的用户管理所有集群。 3）该目录的所有者设置为当前用户 安装JDK，配置Java环境1）将jdk安装包放在家目录下 2）解压到opt目录下 sudo tar zxvf jdk-8u131-linux-x64.tar.gz -C /opt 此时在/opt目录下：会有一个jdk1.8.0_1313）创建软链接 sudo ln -snf /opt/jdk1.8.0_131 /opt/jdk 注意：创建软连接的目的是为了，我们在做项目的时候，可能会用到不同的jdk版本，这是要换软件的话，只需要修改软链接就可以了。而不用修改配置文件。 4）配置环境变量 局部环境变量：~/.bashrc 全局环境变量：/etc/profile export JAVA_HOME=/opt/jdk export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib export PATH=$PATH:$JAVA_HOME/bin source 相关文件（更新配置文件）5）查看是否安装成功 java、javac、java -version搭建伪分布式集群安装Hadoop1）解压hadoop安装包到opt目录下 sudo tar zxvf hadoop-2.8.1.tar.gz -C /opt2）创建软链接 ln -snf /opt/hadoop-2.8.1 /opt/hadoop 3）配置环境变量 在/etc/profile文件中加入以下内容： export HADOOP_HOME=/opt/hadoop export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin source /etc/profile4）使用hadoop version命令测试是否配置成功 配置Hadoop配置文件存放在/opt/hadoop/etc/hadoop中有很多个文件，暂时只需要修改的只有几个 1）hadoop-env.sh export JAVA_HOME=${JAVA_HOME}改成export JAVA_HOME=/opt/jdk 注意：在配置文件中有提示我们怎么设置，我们一般不删除，二回选择注释它的提示。 2）core-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt; &lt;value&gt;hdfs:&#x2F;&#x2F;1.0.0.5:9000&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 分析：1.0.0.5是你主节点所在主机的ip，而9000为端口 3）hdfs-site.xml 1234567891011121314151617181920212223&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.nameservices&lt;&#x2F;name&gt; &lt;value&gt;hadoop-cluster&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;nn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.ch eckpoint.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;snn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.edits.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;snn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;hdfs&#x2F;dn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 4）mapred-site.xml 在hadoop的相关目录中没有此文件，但是有一个mapred-site.xml.template文件，将该文件复制一份为mapred-site.xml cp mapred-site.xml.template mapred-site.xml123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt; &lt;value&gt;yarn&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; 5）yarn-site.xml 12345678910111213141516&lt;configuration&gt; &lt;!-- 指定ResourceManager的地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt; &lt;value&gt;1.0.0.5&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;!-- 指定reducer获取数据的方式--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt; &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt; &lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;&#x2F;name&gt; &lt;value&gt;file:&#x2F;&#x2F;&#x2F;data&#x2F;hadoop&#x2F;yarn&#x2F;nm&lt;&#x2F;value&gt; &lt;&#x2F;property&gt;&lt;&#x2F;configuration&gt; Hadoop目录权限问题注意： 如果使用sudo启动hadoop的相关进程，这几个目录的权限可以不用管。如果是使用当前的用户启动相关进程，对于opt目录，当前用户得有读写权限，对于/data目录也需要读写权限。 sudo mkdir -p /data/hadoop/hdfs/nn sudo mkdir -p /data/hadoop/hdfs/dn sudo mkdir -p /data/hadoop/hdfs/snn sudo mkdir -p /data/hadoop/yarn/nm启动Hadoop启动HDFS集群 hadoop-daemon.sh start namenode 启动主节点 hadoop-daemon.sh start datanode 启动从节点 启动YARN集群yarn-daemon.sh start resourcemanager yarn-daemon.sh start nodemanager 启动作业历史服务器mr-jobhistory-daemon.sh start historyserver jps命令查看是否启动成功 HDFS和YARN集群都有相对应的WEB监控页面HDFS：http://ip:50070 YARN：http://ip:8088 YARN集群的操作—-测试Hadoop是否配置成功计算PI值的作业： yarn jar /opt/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.1.jar pi 4 100 配置免密码登录1）在所有的主从节点中执行 如果以前配置过免密登录的话，建议删除重新建立过，因为我们需要配置的是多台服务器： rm -r ~/.ssh 执行ssh-keygen为了在主节点中生成公钥和私钥，在从从节点生成.ssh目录 2）在主节点中执行 scp /.ssh/id_rsa.pub 从节点的用户名@从节点ip: 注意：第一次远程连接的话，首先输入yes，然后是从节点密码 3）在所有的从节点中执行 我们把主节点的公钥已经拿到了所有的从节点中，接下来就是： cat id_rsa.pub&gt;&gt;.ssh/authorized_keys当中]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>毕业设计</tag>
        <tag>graduation</tag>
        <tag>hadoop</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记[二]]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括函数默认参数Parameter、对象代理Proxy、解构赋值以及多行字符串/模版变量 默认参数 (parameter)通过es6很方便地给函数设置一个默认参数1234567891011121314151617181920212223242526272829/** * es5中函数默认参数 * 如果需要这个函数的参数可填可不填，不填的话就给一个默认值 * 那么在函数体内要写一个判断或者采用或表达式（||） */function fn(a,b,c)&#123; if(b == null)&#123; b = 2 &#125; c = c || 3 return a+b+c&#125;fn(1) // 6fn(1,3) // 7fn(1,3,4) // 8/** * es6中函数默认参数 */function fn(a,b = 2,c = 3)&#123; return a+b+c&#125;//该函数使用babel编译过来的结果得到：// function fn(a) &#123;// var b = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;// var c = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 1;// return a+b+c;// &#125; 利用es6中的默认参数来进行对函数必选参数的检查:123456789101112131415function cheakParameter()&#123; throw new Error('can\'t be empty!')&#125;function fn(a=cheakParameter(),b=2,c=3)&#123; return a+b+c&#125;try&#123; fn()&#125;catch(e)&#123; console.log(e)&#125;finally&#123; &#125; es6中可变参数的写法1234567891011121314151617181920212223242526/** * es5中可变参数的写法 */function fn()&#123; var a = Array.prototype.slice.call(arguments) //arguments是一个伪数组，所以用数组的方式来写需要对数组的原型对象call()一下 var sum = 0 a.forEach(function(item)&#123; sum+=item*1 &#125;) return sum&#125;console.log(fn(1,2,3))/** * es6中可变参数的写法 */function fn(...a)&#123; // ... 是扩展运算符 ...a 就是可变参数 var sum = 0 a.forEach(item =&gt; &#123; sum += item*1 &#125;) return sum&#125;console.log(fn(1,2,3)) 对象代理 (Proxy) 如果有要求需要封装一份数据，这个数据只让内部的方法访问到，而外部的API无法访问高级程序语言(比如JAVA、C#等)有一个私有属性，就可以直接达到这样的效果在Javascript中，es3、es5只能通过模拟私有变量的方法达到这样的效果，但写法复杂而在es6中,它提供了一个对象代理(Proxy)的方法来解决私有变量的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * es3中采用构造函数来对数据进行保护 */var Person = function()&#123; var data = &#123; name: 'es3', age: 23, sex: 'male', &#125; this.get = function(key)&#123; return data[key] &#125; this.set = function(key,value)&#123; if(key !== 'sex')&#123; //这里就设置了sex值不可改，即达到了保护的效果 data[key] = value &#125; &#125;&#125;//声明一个实例var person = new Person()//读取console.table(&#123;name:person.get('name'),age:person.get('age'),sex:person.get('sex')&#125;)//修改person.set('name','es3-cname') // 修改成功person.set('sex','female') // 不会报错，但不会被执行成功/** * es5中采用defineProperty来对数据进行保护 */var person = &#123; name: 'es5', age: 25&#125;Object.defineProperty(person,'sex',&#123; writable: false, value: 'male'&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125;/** * es6中采用对象代理来对数据进行保护 */let Person = &#123; name: 'es6', age: 26, sex: 'male'&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; return target[key] &#125;, set(target,key,value)&#123; if(key !== 'sex')&#123; //和es3中很相似，也是声明两个方法来获取和改变数据的值 target[key] = value &#125; &#125;&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125; 解构赋值12345678910111213141516171819202122/** * es5中取得对象属性的值或者数组的值 */var obj = &#123;a:100,b:200,c:300&#125;var arr = ['xxx','yyy','zzz']var a = obj.avar b = obj.bvar x = arr[0]var y = arr[1]var z = arr[2]/** * es6中的解构赋值 */const obj = &#123;a:100,b:200,c:300&#125;const arr = ['xxx','yyy','zzz']const &#123;a,c&#125; = objconst [x,y,z] = arr 多行字符串/模板变量 (`$`)1234567891011121314151617181920212223242526/** * es5中的多行字符串/模板变量 */var name = 'zhangsan'var age = 20var html = ''html += '&lt;div&gt;'html += ' &lt;p&gt;' + name + '&lt;/p&gt;'html += ' &lt;p&gt;' + age + '&lt;/p&gt;'html =+ '&lt;/div&gt;'/** * es6中的多行字符串/模板变量 */const name = 'zhangsan'const age = 20const html = ` &lt;div&gt; &lt;p&gt;$&#123;name&#125;&lt;/p&gt; &lt;p&gt;$&#123;age&#125;&lt;/p&gt; &lt;/div&gt;`//使用反引号能写多行字符串，还可以用$符号进行引入变量]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>parameter</tag>
        <tag>proxy</tag>
        <tag>解构赋值</tag>
        <tag>模版字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记[一]]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括变量定义关键字let&amp;const、块级作用域Scope、箭头函数Arrow Function、类Class以及异步解决方案Promise 变量定义关键字 (let &amp; const)es5中定义常量 JS中全局对象是window，对于常量来说就可以将它绑定到window上 所用到的就是Object的defineProperty方法，它的第三个参数是一个描述符 123456789/** * es5中定义一个常量的写法 */Object.defineProperty(window,"a",&#123; value: 100, writable: false,&#125;)a = 200 //不会报错，但是没有执行成功console.log(a) //100 es6中定义常量1234567891011&#x2F;** * es6中定义一个常量的写法 * 直接使用const修饰符 *&#x2F;let b &#x3D; 100b &#x3D; 200 &#x2F;&#x2F;正确console.log(b) &#x2F;&#x2F; 200const c &#x3D; 100c &#x3D; 200 &#x2F;&#x2F;报错console.log(c) &#x2F;&#x2F; 100 块级作用域 (Scope)解决es5中for循环使用var来声明i时候的变量提升问题12345678910111213141516171819202122232425262728293031/** * es5中for循环使用var关键字来声明i */var array = []for(var i=0;i&lt;3;i++)&#123; //这里有一个变量提升的问题 array[i] = function()&#123; //这里的i分别为 1、2、3 return i*2 //而这里返回的是一个函数表达式，此时是对i这个对象的引用，而不是对i的值的引用，所以i不会取到值，直到执行的时候i才能取到值。这个地方也是一个闭包。 &#125;&#125;console.table([ //此时函数表达式被执行，取到了i的值，但i已经变成了3 array[0](), array[1](), array[2]()])/** * es6中for循环使用let关键字来声明i */var array = []for(let i=0;i&lt;3;i++)&#123; array[i] = function()&#123; //使用let会有一个块级作用域，把当前i的值存下来使用 return i*2 //循环到下一步的时候会生成一个新的作用域，这样就不会出现变量提升的问题 &#125;&#125;console.table([ array[0](), array[1](), array[2]()]) es6中有块级作用域 由于es5中没有块级作用域，所以需要使用立即执行函数来指定（隔离）一个块作用域而在es6中只需要使用一对大括号就能直接指定一个块作用域 1234567891011121314151617181920212223242526272829303132/** * es5无块级作用域 * 在for循环外面还是可以取到item的值 */var obj = &#123;a:100,b:200&#125;for(var item in obj)&#123; console.log(item)&#125;console.log(item) // b (这里也有一个变量提升的问题)/** * 由于es5中没有块级作用域 * 所以为了程序的可读性，es5中推荐这么写 */var obj = &#123;a:100,b:200&#125;var itemfor(item in obj)&#123; console.log(item)&#125;console.log(item) // b/** * es6中有块级作用域 * 在for循环外面取不到item的值 */const obj = &#123;a:100,b:200&#125;for(let item in obj)&#123; console.log(item)&#125;console.log(item) // 报错: item is not defined 箭头函数 (Arrow Function)箭头函数语法形式123() =&gt; &#123;&#125; 小括号里面接收参数,若参数只有一个那么可以省略小括号大括号里面是函数体，若函数体只有一行那么可以省略大括号 map()方法中的箭头函数12345678910111213141516171819/** * es5中function函数 */var arr = [1,2,3]arr.map(function(item)&#123; return item+1&#125;)/** * es6中的箭头函数 */const arr = [1,2,3]arr.map(item =&gt; item + 1) //只传入一个参数，且函数体只有一行arr.map((item,index) =&gt; &#123; //传入多个参数，且函数体有多行 console.log(index) return item + 1&#125;) call()方法改变this的指向1234567891011121314151617181920212223242526/** * es5中使用call()方法来改变function函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(function(item)&#123; console.log('此时的this:',this) // 此时的this: Window &#125;)&#125;fn.call(&#123;a:100&#125;)/** * es6中使用call()方法来改变箭头函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(item =&gt; &#123; console.log('此时的this:',this) // 此时的this: &#123;a: 100&#125; &#125;)&#125;fn.call(&#123;a:100&#125;) function函数与箭头函数中this的指向对比 在es5的function函数中，this的指向是函数被调用时的对象，也就是说该函数在被执行的时候，哪个对象调用了该函数，这个this指向的就是那个对象 在es6中的箭头函数中，箭头函数没有自己的this。箭头函数的this是继承而来，默认指向在定义该箭头函数时所处的对象(宿主对象) 12345678910111213141516171819202122232425262728293031323334/** * es5中的function函数中的this指向 */var Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: function()&#123; return this.a &#125; &#125;&#125;var foo = new Foo()console.log(foo.c.b()) // a+/** * es6中的箭头函数中的this指向 */let Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: ()=&gt;&#123; return this.a &#125; &#125;&#125;let foo = new Foo()console.log(foo.c.b()) // a 类 (class)构造函数123456789101112131415161718192021222324252627282930313233343536/** * es5中构造函数的写法 */function MathHandle (x,y)&#123; this.x = x this.y = y&#125;MathHandle.prototype.add = function() &#123; return this.x + this.y&#125;var m = new MathHandle(1,2)console.log(m.add())/* * es6中构造函数的写法 */class MathHandle&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; add()&#123; return this.x + this.y; &#125;&#125; const m = new MathHandle(1,2);console.log(m.add()); // 3console.log(typeof MathHandle); // function//构造函数的显式原型的constructor属性值为构造函数本身console.log(MathHandle.prototype.constructor); // class MathHandle&#123;&#125; 类的继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * es5中继承的写法 *///动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125; // 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat()/** es6中继承的写法*/class Animal&#123; // 构造函数 constructor(name)&#123; this.name = name &#125; // 成员方法 eat()&#123; console.log(this.name + ' eat') &#125;&#125;// 继承class Dog extends Animal&#123; constructor(name)&#123; super(name) // 只要出现继承extends，就必须写super,而且需要把super放在constructor里面的第一行 this.name = name &#125; bark()&#123; console.log(this.name + ' bark') &#125;&#125;const dog = new Dog('hashiqi')dog.bark()dog.eat() 类的setter和setter ES6在类的内部可以使用get和set关键字来对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819202122232425/** * es6中的setter、getter */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; get getName()&#123; //这里的get形似方法，但它实际上是一个属性 return this.name &#125; set setName(value)&#123; this.name = value &#125;&#125;let par = new Parent()console.log('getter: ',par.getName)console.log('setter: ', par.setName = 'es6-cname')console.log(par.name,par.getName)//因为setter是一个属性，所以不能写成par.setName(es6-cname)//而是要写成赋值表达式的形式 类的静态方法和静态变量12345678910111213141516171819/** * es6中的静态方法和静态属性 */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; static tell()&#123; //定义类的静态方法使用关键字static console.log('es6-static') &#125;&#125;Parent.type = 'es6-class' //静态属性没有关键字去声明//定义类的静态属性是在类定义完成后直接在类的外面进行赋值表达式定义Parent.tell() // 静态方法是通过类去调用，而不是通过类的实例去调用console.log(Parent.type) // 打印静态对象 异步 (Promise)Promise的介绍Promise是异步编程的一种解决方案，比传统的解决方案–回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise。 所谓Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作）的结果。*从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 * 也之所以它是一个对象，所以它可以用来保存状态，从而解决了普通回调函数中的“回调地狱”以及“不能return”这两个问题。 三种状态:Promise对象的状态不受外界影响: pending: 进行中 fulfilled: 已经成功 rejected: 已经失败 状态改变:Promise对象的状态改变,只有两种可能: 从pending变为fulfilled 从pending变为rejected 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型） 使用Promise加载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * es5中的回调函数 */function loadimg(src,callback,failed)&#123; var img = document.createElement('img') img.onload = function()&#123; callback(img) &#125; img.onerror = function()&#123; failed() &#125; img.src = src&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'loadimg(src,function(img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)/** * es6中的promise * 1.new Promise实例，而且要在后面return这个实例 * 2.new Promise时候要传入一个函数，该函数有resolve、reject两个参数 * 3.成功时候执行resolve()，失败时候执行reject() * 4.then()方法监听结果，并可以多次执行，达到分批处理的效果 */function loadimg(src)&#123; const promise = new Promise(function(resolve ,reject)&#123; const img = document.createElement('img') img.onload = function ()&#123; resolve(img) &#125; img.onerror = function()&#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'var result = loadimg(src)//传两个函数作为参数，分别是成功和失败的回调result.then(function (img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)// 可以集成可以扩展可以分批处理,变得更加灵活result.then(function(img)&#123; console.log(img.height)&#125;) 多步调用:事件A–&gt;事件B–&gt;事件C123456789101112131415161718192021222324let ajax = function()&#123; console.log('start') return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-A') &#125;, 500); reslove() &#125;)&#125;ajax().then(function()&#123; //then()方法继续返回new Promise实例，就可以达到串联的效果 return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-B') &#125;, 1000); reslove() &#125;)&#125;).then(function()&#123; return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-C') &#125;, 1500); &#125;)&#125;) 异步过程中使用catch捕获错误1234567891011121314151617let ajax = function (num) &#123; return new Promise(function(reslove,reject)&#123; if(num&lt;4)&#123; reslove() &#125;else&#123; throw new Error('It Should under five!!!') &#125; &#125;)&#125;for (let i = 1;i &lt; 5;i++) &#123; ajax(i).then(function()&#123; console.log('i =',i) &#125;).catch(function(err)&#123; console.log('catch',err) &#125;)&#125; 异步加载图片的两个示例 所有图片都加载完之后再添加到页面 Promise.all()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中所有Promise实例的状态都发生改变，这个新的实例对象才会改变。 123456789101112131415161718192021222324252627//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(imgs)&#123; imgs.forEach(function(img)&#123; document.body.appendChild(img) &#125;)&#125;//高级用法Promise.all([ loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'), loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg')]).then(showImgs) 只要有一张图片加载完就添加到页面 Promise.race()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中这多个Promise实例的状态只要有一个发生改变，这个新的实例对象就会改变。 123456789101112131415161718192021222324//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(img)&#123; document.body.appendChild(img)&#125;Promise.race([ loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg'), loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'),]).then(showImgs)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>scope</tag>
        <tag>arrow function</tag>
        <tag>箭头函数</tag>
        <tag>class</tag>
        <tag>类</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则表达学习]]></title>
    <url>%2F2017%2F05%2F24%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是正则表达式 **正则表达式**（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，搜索模式可用于文本搜索和文本替换。 正则表达式的语法 > **/主体/修饰符(可选)** 其中，第一个“/“是这个正则表达式的头部,主体是我们想要匹配的模式,第二个“/“是这个正则表达式的尾部，修饰符有三个： i（intensity）：大小写不敏感； g（global）：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行； m（multiple）：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用。 正则表达式的常用方法 test( ) : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false。用法：正则.test(字符串) 123456789// 测试是否是数字：var str = '374829348791';var re = /\D/; // \D代表非数字if( re.test(str) )&#123; // 返回true,代表在字符串中找到了非数字。 console.log('不全是数字');&#125;else&#123; console.log('全是数字');&#125; search( ) ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回-1。用法：字符串.search(正则) 123456// 在字符串中找字母b，且不区分大小写：var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i'); 也可以这样写console.log( str.search(re) ); // 1 match( ) : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： 字符串.match(正则)量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）。 12345//找出指定格式的所有数字，如下找到 123，54，33，879var str = 'haj123sdk54hask33dkhalsd879';var re = /\d+/g; // 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。console.log( str.match(re) ); // [123，54，33，879] match方法也会返回自己的子项，如下： 12345// 当match不加g的时候才可以获取到子项的集合:var str = 'abc';var re = /(a)(b)(c)/;console.log( str.match(re) ); //[abc,a,b,c](返回的是匹配结果,以及每个子项) replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： 字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符） 12345678910111213141516171819202122//敏感词过滤，比如 我爱北京天安门，天安门上太阳升。------我爱*****，****上太阳升。即北京和天安门变成*号。~~//一开始我们可能会想到这样的方法：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,'*'); console.log(str2) //我爱**，*上太阳升 //这种只是把找到的变成了一个*，并不能几个字就对应几个*。~~//要想实现几个字对应几个*，我们可以用回调函数实现：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,function(str)&#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; //所以搜索到了几个字就返回几个* &#125;);console.log(str2) //我爱*****，***上太阳升 //整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 正则表达式中的字符 * **^ : 正则的最开始位置，就代表起始的意思。**注意：/[ ^ a] / 和 / ^ [a]/ 是不一样的，前者是排除的意思，后者是代表首位。 eg:"^ The"--表示所有以"The"开始的字符串（"There"，"The cat"等）; 1234567// 判断是不是QQ号:// 首先想QQ号的规则：1.首位不能是0 ；2.必须是 5-12位的数字。 var str = '1445427773';var re = /^[1-9]\d&#123;4,11&#125;$/;console.log( re.match(str) ); $ : 正则的最后位置，就代表结束的意思。eg:”of despair$”–表示所以以”of despair”结尾的字符串; 12345678910// 去掉前后空格（面试题经常出现）:function trim(str)&#123; var re = /^\s+|\s+$/g; // |代表或者 \s代表空格 +至少一个 前面有至少一个空格 或者后面有至少一个空格 且全局匹配 return str.replace(re,''); //把空格替换成空&#125;var str = ' hello ';console.log('('+str+')');console.log( '('+trim(str)+')' ); //为了看出区别所以加的括号。 ( ) : 小括号，叫做分组符。就相当于数学里面的括号。如下： 12345678var str = '2013-6-7';var re1 = /\d-+/g; // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为： 3- 6-var re2 = /(\d-)+/g; // 全局匹配数字，横杠，数字和横杠整体数量至少为1 3-6-var re3 = /(\d+)(-)/g; // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-console.log(str.match(re1));console.log(str.match(re2));console.log(str.match(re3)); 同时，正则中的每一个带小括号的项，都叫做这个正则的子项。子项在某些时候非常的有用，比如下面这个例子： 123456789101112131415// 让2013-6-7 变成 2013.6.7：var str = '2013-6-7';var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; // replace()中如果有子项， // 第一个参数：$0（匹配成功后的整体结果 2013- 6-）, // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6) // 第三个参数 : $1(匹配成功的第二个分组，这里指的是- - - ) return $1 + '.'; // 分别返回2013. 6. &#125;);console.log( str ); // 整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7 转义字符: \s : 空格 \S : 非空格 \d : 数字 \D : 非数字 \w : 字符 ( 字母 ，数字，下划线_ ) \W : 非字符 .（点）: 任意字符 . : 真正的点 \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 1234567var str1 = 'onetwo';var str2 ="one two";var re = /one\b/; // e后面必须是独立的 可以是起始，空格，或结束console.log( re.test(str1) ); // falseconsole.log( re.test(str2) ); // true 量词：代表出现的次数。 {n,m} : 至少出现n次，最多m次;“ab{3,5}”：表示一个字符串有一个a跟着3到5个b;“ab{2,}”：表示一个字符串有一个a跟着至少2个b; {n,} : 至少n次; * : 任意次,相当于{0,};“ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； ？：零次或一次,相当于{0,1};“ab?”：表示一个字符串有一个a后面跟着零个或者一个b; + ：一次或任意次,相当于 {1,};“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多; {n} ：正好n次;“ab{2}”：表示一个字符串有一个a跟着2个b（”abb”). [ ]： 表示某个集合中的任意一个。方括号表示某些字符允许在一个字符串中的某一特定位置出现。“[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”);“[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”);“ ^ [a-zA-Z]”：表示一个以字母开头的字符串;“[0-9]%”：表示一个百分号前有一位的数字;“, [a-zA-Z0-9] $ “ ：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用’ ^ ‘表示不希望出现的字符，’ ^ ‘应在方括号里的第一位。（如：”%[ ^ a-zA-Z]%”表示两个百分号中不应该出现字母)。为了逐字表达，你必须在” ^ .$ ( ) ¦ * + ? { \ “这些字符前加上转移字符’ \ ‘。请注意在方括号中，不需要转义字符。 12345// 匹配HTML标签 比如&lt;div class="b"&gt;hahahah &lt;/div&gt; 找出标签&lt;div class="b"&gt;&lt;/div&gt;var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号 中间至少一个非右括号的内容(因为标签里面还有属性等一些东西)，然后匹配右括号var re = /&lt;[\w\W]+&gt;/g; //匹配左括号 中间至少一个字符或者非字符的内容，然后匹配右括号// 其实就是找到左括号，然后中间可以有至少一个内容，一直到找到右括号就代表是一个标签。 \a ：表示重复的某个子项。比如： \1 : 重复的第一个子项; \2 : 重复的第二个子项; 12/ (a) (b) (c) \1/ // 匹配 abca/ (a) (b) (c) \2/ // 匹配 abcb 12345678910111213141516171819202122// 找重复项最多的字符个数(面试题中经常问到）:var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split(''); // 把字符串转换为数组str = arr.sort().join(''); // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串console.log(str); // aaddjjkklsssssssssssssssssvar value = '';var index = 0; var re = /(\w)\1+/g; // 匹配字符，且重复这个字符，重复次数至少一次。str.replace(re,function($0,$1)&#123; // alert($0); 代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss // alert($1); 代表每次匹配成功的第一个子项，也就是\w: a d j k l S if(index&lt;$0.length)&#123; // 如果index保存的值小于$0的长度就进行下面的操作 index = $0.length; // 这样index一直保存的就在最大的长度 value = $1; // value保存的是出现最多的这个字符 &#125;&#125;); console.log('最多的字符:'+value+',重复的次数:'+index); // s 17 split( ):字符串中的方法，把字符串转成数组。sort( ):数组中的排序方法，按照ACALL码进行排序。join( ):数组中的方法，把数组转换为字符串 常用的一些正则表达式 1. 校验是否全由数字组成（[0-9]中的字符出现次数的范围是1到20次): > /\^[0-9]{1,20}$ / 校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串: /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$ / 校验用户姓名：只能输入1-30个以字母开头的字串: /^[a-zA-Z]{1,30}$/ 校验密码：只能输入6-20个字母、数字、下划线: /^(\w){6,20}$/ 校验普通电话、传真号码：可以“+”或数字开头，可含有”-“ 和 “ “ /^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/ 校验URL: /^http[s]{0,1}://.+$/ 校验身份证： /[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x/ 校验Email(起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。)： /^\w+@[a-z0-9]+(.[a-z]+){1,3}$ / JavaScript正则表达式大全（过滤Emoji的最佳实践）一、校验数字的表达式 1 数字：^[0-9]$ 2 n位的数字：^\d{n}$ 3 至少n位的数字：^\d{n,}$ 4 m-n位的数字：^\d{m,n}$ 5 零和非零开头的数字：^(0|[1-9][0-9])$ 6 非零开头的最多带两位小数的数字：^([1-9][0-9])+(.[0-9]{1,2})?$ 7 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ 8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$11 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]$12 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$13 非负整数：^\d+$ 或 ^[1-9]\d|0$14 非正整数：^-[1-9]\d|0$ 或 ^((-\d+)|(0+))$15 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$17 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9]))$18 负浮点数：^-([1-9]\d*.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9]*.[0-9]+)|([0-9][1-9][0-9])))$19 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d|0.\d[1-9]\d|0?.0+|0)$ 二、校验字符的表达式 1 汉字：^[\u4e00-\u9fa5]{0,}$ 2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3 长度为3-20的所有字符：^.{3,20}$ 4 由26个英文字母组成的字符串：^[A-Za-z]+$ 5 由26个大写英文字母组成的字符串：^[A-Z]+$ 6 由26个小写英文字母组成的字符串：^[a-z]+$ 7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$11 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+12 禁止输入含有的字符：[^\x22]+ 三、特殊需求表达式 1 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+)*.\w+([-.]\w+)$ 2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 5 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 7 身份证号：15或18位身份证：^\d{15}|\d{18}$15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$ 8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.[a-z])(?=.[A-Z]).{8,10}$12 日期格式：^\d{4}-\d{1,2}-\d{1,2}13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9])$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9])$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})(.[0-9]{1,2})?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3}))(.[0-9]{1,2})?$24 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) 详见此文章]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现垂直水平居中]]></title>
    <url>%2F2017%2F03%2F18%2FCSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[CSS实现垂直水平居中 第一种方法（position:absolute，负margin法） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的左外边距、上外边距为宽高的负1/2--&gt;margin-left:-100px;margin-top:-200px;&#125; 优点：兼容性好；缺点：必须固定元素的宽高 第二种方法（使用css3的新属性transform:translate(x,y)） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的相对于自身的偏移度为负50%(也就是元素自身尺寸的一半)--&gt;transform:translate(-50%,-50%);&#125; 这是css3里的样式，在移动端用得较多；缺点：兼容性不好，只支持IE9+的浏览器。 第三种方法（设置margin为auto） 1234567891011121314151617div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、下、左、右都为0--&gt;left:0;right:0;top:0;bottom:0;&lt;!--设置元素的margin样式值为 auto--&gt;margin:auto;&#125; 优点：兼容性较好；缺点：不支持IE7以下的浏览器。 第四种方法（inline-block方法） 场景： 一个块状元素A内 有若干个块状元素B，要达到的效果是 ，所有块状元素B 在 元素A 内水平居中显示。 12345&lt;div class="A"&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt;&lt;/div&gt; 首先，我们要设置元素A的大小为500px，设置背景色为green方便查看。 1234.A｛ width:500px; backgrond-color:green;｝ 然后， 设置所有元素B 的宽度为100px，高度为100px，外边据都为5px，背景色为#000方便查看。 123456.B｛ width:100px; height:100px; magin:5px; backgrond-color:green;｝ 此时的效果： 我们要做的是，先把所有的元素B都设置为行内块级元素，让他们都排成一行，即使用：display:inline-block； 最后就是让所有的元素B居中了， 到这里，相信很多人就猜到下一步要做什么了，我锦上添花，解释一下。 先想一想，如果是行内元素， 我们一般让它怎么居中呢？答：当然是给它的父容器加一个text-align:center的样式。 这里我们已经把所有的元素B变成了行内块， 也就有了行内元素的特性，所以，我们下一步要做的就是给元素A加text-align:center， 这样我们的目的就达到了，请看效果： 优点：兼容性较好；缺点：父元素和子元素的宽度都要已知。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>study</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局语法教程]]></title>
    <url>%2F2017%2F03%2F14%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Info: Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局: 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局: 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀: 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end`。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）: 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行: 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行: wrap：换行，第一行在上方: wrap-reverse：换行，第一行在下方: flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap: 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式: 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: 12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用: 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值: 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 123456orderflex-growflex-shrinkflex-basisflexalign-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0: 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大: 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小: 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小: 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选: 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS经典布局问题整理]]></title>
    <url>%2F2017%2F03%2F14%2FCSS%20%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Info: CSS布局相关。 CSS基础知识 MDN-CSS入门教程： MDN的官方文档 学习CSS布局： 排版不错，简短精悍 CSS定位问题主要就是经典的绝对定位、相对定位问题 10个文档学布局： 通过十个例子讲解布局，主要涉及相对布局，绝对布局，浮动。 百度前端学院笔记 - 理解绝对定位： 文章本身一般，几篇参考文献比较详细 HTML和CSS高级指南之二——定位详解： 介绍浮动的使用，详细介绍定位的技巧，包括如何准确的给元素在 X 轴、Y 轴和 Z 轴定位 三栏式布局涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局圣杯：父盒子包含三个子盒子（左，中，右） 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 .left {margin-left:-100%;} 把左边的盒子拉上去 .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去 父盒子设置左右的 padding 来为左右盒子留位置 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖 1234567&lt;!-- 圣杯的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 双飞翼布局双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置 123456789&lt;!-- 双飞翼的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt; &lt;div class="middle-inner"&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 圣杯和双飞翼异同圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。 主要区别在于 如何使中间盒子的内容不被左右盒子遮挡： 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。 利用浮动实现我自己使用浮动也实现了三栏式布局：左边盒子左浮动，右边盒子右浮动，中间盒子利用 margin-left 和 margin-right 来为左右盒子留位置，同时父盒子设置 overflow: auto; 来避免子盒子溢出。 1234567&lt;!-- 浮动实现的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt; &lt;!-- 中间的 div 必须写在最后面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt;&lt;/div&gt; 三栏式布局参考下面几个链接: CSS三栏布局——中间固定两边自适应宽度： w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽 简书 - 圣杯布局和双飞翼布局(前端面试必看)：只讲了圣杯，不过特别详细 In Search of the Holy Grail：圣杯布局的来源 百度前端学院笔记 - 三栏式布局之双飞翼与圣杯：百度前端学院学员的前端学习笔记 三栏式布局涉及到负 magin 和 清除浮动的问题。 负magin 负margin用法权威指南：The Definitive Guide to Using Negative Margins 的译文,介绍了负 magin 的一些性质和很多实用技巧 简书 - margin为负值产生的影响和常见布局应用：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高) 博客园 - CSS布局奇淫巧计之-强大的负边距：和上文内容差不多 简单总结几点： 不使用 float 的话，负 margin 元素是不会破坏页面的文档流。所以如果你使用负 margin 上移一个元素，所有跟随的元素都会被上移(而 relative 定位的元素则不同，会保留原位置，影响文档流) 当 static 元素的 margin-top/margin-left 被赋予负值时，元素将被拉进指定的方向 如果你设置 margin-bottom/right 为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素 当元素不存在 width 属性或者 width: auto 的时候，负 margin 会增加元素的宽度 margin-top 为负值不会增加高度，只会产生向上位移;margin-bottom 为负值不会产生位移，会减少自身的供 CSS 读取的高度，影响下方的元素位置；上下相邻的元素两者均为负时，效果不叠加，取负值更多的那个效果 清除浮动清除浮动主要是为了解决高度塌陷问题。而简单的 clear: both 并不能解决这个问题，所以引出了许多解决方案。 StackOverflow - What methods of ‘clearfix’ can I use?：清除浮动黑科技完整解读 那些年我们一起清除过的浮动：神文，把“清除浮动”定义为“闭合浮动”，把问题由来和解决方案都讲清楚了，并且分析了各种解决方案的优劣。 各种解决方案在上面的链接里有很详细的说明了，这里就不赘述了。大体分为两类： 其一，通过在浮动元素的末尾添加一个空元素，设置 clear: both 属性，after 伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素 其二，通过设置父元素 overflow 或者 display: table 属性来闭合浮动 顺便补充一句，clear float(例如 clear: left) 是对某个元素设置，以避免其某一边有浮动元素，即对当前元素产生约束，约束的边界为其他的浮动元素。对于已经浮动的元素，设置 clear float 是无效的。 居中布局Centering in CSS: A Complete Guide：非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码文章大致结构： 1 水平居中 对于行内元素(inline)：text-align: center 对于块级元素(block)：设置宽度且 marigin-left 和 margin-right 是设成 auto 对于多个块级元素：对父元素设置 text-align: center;，对子元素设置 display: inline-block;；或者使用 flex 布局 2 垂直居中 对于行内元素(inline) 单行：设置上下 pandding 相等；或者设置 line-height 和 height 相等 多行：设置上下 pandding 相等；或者设置 display: table-cell; 和 vertical-align: middle;；或者使用 flex 布局；或者使用伪元素 对于块级元素(block)：下面前两种方案，父元素需使用相对布局 已知高度：子元素使用绝对布局 top: 50%;，再用负的 margin-top 把子元素往上拉一半的高度 未知高度：子元素使用绝对布局 position: absolute; top: 50%; transform: translateY(-50%) 使用 Flexbox：选择方向，justify-content: center 3 水平垂直居中 定高定宽：先用绝对布局 top: 50%; left: 50%;，再用和宽高的一半相等的负 margin 把子元素回拉 高度和宽度未知：先用绝对布局 top: 50%; left: 50%;，再设置 transform: translate(-50%, -50%) 使用 Flexbox：justify-content: center; align-items: center 响应式设计响应式设计（Responsive Design) 是一种让网站针对不同的浏览器和设备呈现不同显示效果的策略。 媒体查询(Media Queries)是做此事所需的最强大的工具。 注： Responsive Web Design ＝ RWD，Adaptive Web Design ＝ AWD RWD： 采用 CSS 的 media query 技术 流体布局（fluid grids） 自适应的图片/视频等资源素材（为小、中、大屏幕做一些优化，目的是让任何尺寸的屏幕空间都能得到充分利用） AWD： CSS media query 技术（仅针对有限几种预设的屏幕尺寸设计） 用 JavaScript 来操作 HTML 内容 在服务器端操作 HTML 内容（比如为移动端减少内容，为桌面端提供更多内容） 可以参考 Bootstrap 的网格系统：http://getbootstrap.com/css/#grid-less The Bootstrap 3 grid system has four tiers of classes: xs (phones), sm (tablets), md (desktops), and lg (larger desktops). 自己实现网格系统： Creating Your Own CSS Grid System Flexbox布局点我参考本博客另一篇文章。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>position</tag>
        <tag>absolute</tag>
        <tag>relative</tag>
        <tag>flex</tag>
        <tag>float</tag>
        <tag>margin</tag>
        <tag>center</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 先来看看下面代码:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作（DOM常见的API）: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>dom</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识集]]></title>
    <url>%2F2017%2F03%2F12%2FCSS%E7%9F%A5%E8%AF%86%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Info: CSS基础、布局、效果和动画、CSS工程化等 CSS非布局样式字体、字重、颜色、大小、行高字体族 serif 衬线字体族(Times New Roman、MS Georgia、宋体等) sans-serif 非衬线字体族(Arial、Helvetica、幼圆、隶书、楷体等) monospace 等宽字体族(Courier、MS Courier New、Prestige等) cursive 手写体族(Caflisch Script、Adobe Poetica、迷你简黄草、华文行草、静蕾体等) fantasy 梦幻字体族(WingDings、WingDings 2、Symbol等) 多字体fallback 屏显效果好的字体放前面 适用范围小的字体放前面 自定义字体、网络字体在style标签中使用@font-face来指定一个自定义的字体，从而在下面应用这个字体。 字重 font-weight取值范围: 100～900 font-weight: lighter 取决于父级字体大小 font-weight: normal 默认相当于400 font-weight: bold 默认相当于700 font-weight: bolder 取决于父级字体大小 字体 demo12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--字体--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;fonts&lt;/title&gt; &lt;style&gt; body&#123; /* font-family: "monaco"; */ /* font-family: "monaco", "PingFang SC"; */ font-family: "aaaaa", "monaco", "PingFang SC"; &#125; .chinese&#123; font-family: "PingFang SC", "Microsoft Yahei", monospace; /* font-family: "Microsoft Yahei", serif; */ /* font-family: "serif"; */ &#125; .weight&#123; font-weight: bold; font-weight: bolder; font-weight: lighter; font-weight: normal; font-weight: 100; &#125; @font-face &#123; font-family: "IF"; src: url("./IndieFlower.ttf"); &#125; .custom-font&#123; font-family: IF; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="body" id="body"&gt; Hello world 你好，世界 &lt;div class="chinese"&gt;你好&lt;/div&gt; &lt;!-- &lt;div class="weight"&gt;你好 Hello World&lt;/div&gt; --&gt; &lt;div class="custom-font"&gt;你好 Hello World&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; line height 行高会撑开div的高度。inline元素会默认在div里垂直居中，所以可以通过line-height的方式来做这个垂直居中。 行内元素的对齐方式是默认底线对齐(baseline)。可以通过vertical-align这个属性来更改inline元素对齐的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 使用vertical-align:bottom 来解决经典的图片3px缝隙问题--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;line-height&lt;/title&gt; &lt;style&gt; .cc1&#123; font-size:12px; &#125; .cc2&#123; font-size:18px; &#125; .cc3&#123; font-size:24px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style="border:solid 1px red;"&gt; &lt;span style="background:blue;color:#fff;font-size:20px;line-height:60px;"&gt; 居中xfg&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; &lt;/span&gt;&lt;/div&gt; &lt;div class="c1"&gt; &lt;span class="cc1"&gt;第一段&lt;/span&gt; &lt;span class="cc2"&gt;第二段&lt;/span&gt; &lt;span class="cc3"&gt;第三段&lt;/span&gt; &lt;/div&gt; &lt;div style="background:red"&gt; &lt;span&gt;文字&lt;/span&gt; &lt;img src="test.png"/&gt; &lt;/div&gt; &lt;div&gt; &lt;div style="float:left"&gt; &lt;span&gt;第一段&lt;/span&gt; &lt;/div&gt; &lt;div style="float:left"&gt; &lt;span&gt;第二段&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景、边框背景颜色 常见的颜色可以用单词来表示，但很少用(balck、white等) 通常可以使用十六进制的颜色代码或者rgb颜色代码来精准地表示一个颜色(#ffffff、#000000等) 人眼对rgb不是非常敏感，所以可以采用hsl(色相(0°～360°)、饱和度(0～100%)、亮度(0～100%))来表示一个颜色(hsl(0,100%,50%)、hsl(240,50%,65%)) rgba和hsla可以给颜色加上一个透明度 渐变色背景12345678&lt;!--老版IE写法--&gt;background: -webkit-linear-gradient(left, red, green);&lt;!--通用写法--&gt;background: linear-gradient(to right, red, green);&lt;!--0°代表从下往上、90°就代表从左往右，依此推算--&gt;background: linear-gradient(90deg, red, green);&lt;!--渐变区域，可以实现彩虹效果--&gt;background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); 多背景叠加1234&lt;!--可以实现网格效果--&gt;background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%), linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%);background-size: 30px 30px; linear-gradient demo12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;background&lt;/title&gt; &lt;style&gt; body&#123; background:white; &#125; .c1&#123; height:90px; /* background:rgba(255,0,0, .3); */ /* background:url(./test.png); */ &#125; .c2&#123; height:90px; /* background: -webkit-linear-gradient(left, red, green); */ /* background: linear-gradient(to right, red, green); */ /* background: linear-gradient(180deg, red, green); */ /* background: linear-gradient(135deg, red 0, green 10%, yellow 50%, blue 100%); */ background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%), linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%); background-size: 30px 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt; &lt;/div&gt; &lt;div class="c2"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 背景图片和属性（雪碧图）把小图标合成一张大图，通过给元素的公共css设置background-image为该合成图，这样每个元素都会以该合成图为背景，而且页面也只加载一张合成图，然后再给每个元素单独微调其background-position，把多个请求合并成一个。这样就达到了优化网页性能的效果。 base64和性能优化 可以通过在线工具将图片转化成base64编码的形式来引用，从而优化网页性能。 但是此时的图片大小会是之前的三分之四，而且这样引用也会增大CSS的体积。 所以该方法只适用于小图标而且少量的情况，比如一个常用的地方就是loading时候的小图标 多分辨率优化通过修改background-size修改相应的比例来让背景图在移动端设备上也能显示得很清楚。 背景 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;background&lt;/title&gt; &lt;style&gt; .c1&#123; height:900px; background:red url(data:image/png;base64,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); background-repeat: no-repeat; /* background-position: center top; */ /* background-position: 20px 30px; */ /* background-size:100px 50px; */ &#125; .c2&#123; width:20px; height:20px; background:url(./test_bg.png) no-repeat; background-position: -17px -5px; background-size: 261px 113px; &#125; .c3&#123; width:20px; height:20px; background:url(./test_bg.png) no-repeat; background-position: -169px -23px; background-size: 261px 113px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="c1"&gt; &lt;/div&gt; &lt;!-- &lt;div class="c2"&gt; &lt;/div&gt; &lt;div class="c3"&gt; &lt;/div&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 边框使用边框来画一个梯形、三角形、扇形等 滚动、换行滚动行为和滚动条overflow属性有四个值可以取 文字换行CSS通常有三个属性来控制文字换行问题 CSS Hack CSS布局常用布局方法 table表格布局 float+margin布局 inline-block布局 flexbox布局 float+margin布局float基础特性 元素浮动 脱离文档流 但不脱离文本流 float对自身的影响 形成”块”(BFC) 位置尽可能靠上 位置尽可能靠左(右) float对兄弟的影响 上面一般贴着非float元素 旁边贴着float元素 不影响其它块级元素的位置 影响其它块级元素的内部文本 float对父级的影响 从布局上”消失” 高度塌陷 float demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!--经常使用的清除浮动的方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;float &lt;/title&gt; &lt;style&gt; .container&#123; background:red; width:400px; margin:20px; &#125; .p1&#123; background:green; float:left; width:200px; height:50px; &#125; .container2::after&#123; content: 'aaa'; clear:both; display: block; visibility: hidden; height:0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;div class="p2"&gt; 很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字很长的文字 &lt;/div&gt; &lt;/div&gt; &lt;div class="container container2"&gt; &lt;span&gt;写几个字&lt;/span&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;span class="p1"&gt; float &lt;/span&gt; &lt;/div&gt; &lt;div class="container" style="height:200px;background:blue;"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; float+margin实现两栏/三栏布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width:800px; height:200px; &#125; .left&#123; background:red; /* float:left; */ /* height:100%; */ width:200px; position: absolute; height:200px; &#125; .right&#123; background:blue; float:right; width:200px; height:100%; &#125; .middle&#123; background: yellow; margin-left:200px; margin-right:200px; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt; 左 &lt;/div&gt; &lt;div class="right"&gt; 右 &lt;/div&gt; &lt;div class="middle"&gt; 中间 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; inline-block布局 像文本一样去排列block元素 没有清除浮动、高度塌陷等问题 但它需要处理间隙 处理间隙有两种方法： 将父级元素的font-size设为0，然后给子元素的font-size重新设为默认值。 将div标签之间的换行或者空格去除掉。 响应式设计和布局 在不同设备上正常使用 一般主要处理屏幕大小问题 主要方法： 隐藏+折行+自适应空间 rem / viewport / media query 响应式布局 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;responsive&lt;/title&gt; &lt;style&gt; .container&#123; margin:0 auto; max-width:800px; display: flex; border:1px solid black; &#125; .left&#123; display: flex; width: 200px; background:red; margin:5px; &#125; @media (max-width: 640px)&#123; .left&#123; display: none; &#125; &#125; .right&#123; display: flex; flex: 1; background:blue; margin:5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt; 这里是一些不重要的内容，比如友情链接、广告 &lt;/div&gt; &lt;div class="right"&gt; 这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。这里是一些重要的内容，比如一篇文章，文章是整个页面的核心内容。 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;responsive&lt;/title&gt; &lt;style&gt; html&#123; font-size: 20px; &#125; .container&#123; margin:0 auto; max-width:800px; border:1px solid black; &#125; .intro&#123; display: inline-block; width:9rem; height:9rem; line-height: 9rem; text-align: center; border-radius: 4.5rem; border:1px solid red; margin:.3rem; &#125; @media (max-width: 375px)&#123; html&#123; font-size:24px; &#125; &#125; @media (max-width: 320px)&#123; html&#123; font-size:20px; &#125; &#125; @media (max-width: 640px)&#123; .intro&#123; margin:.3rem auto; display: block; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="intro"&gt; 介绍1 &lt;/div&gt; &lt;div class="intro"&gt; 介绍2 &lt;/div&gt; &lt;div class="intro"&gt; 介绍3 &lt;/div&gt; &lt;div class="intro"&gt; 介绍4 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS效果属性box-shadow 营造层次感（立体感） 充当没有宽度的边框 投影 特殊效果 box-shadow: (inset表示内阴影) [水平偏移量] [垂直偏移量] [模糊区域] [扩展区域] [半透明效果/颜色] box-shadow demo12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; background:red; width:150px; height:150px; margin: 50px; box-shadow: 5px 5px 10px 0 rgba(0,0,0,.5); /* box-shadow: inset 5px 5px 10px 0 rgba(0,0,0,.5); */ /* box-shadow: 0 0 0 5px green; */ &#125; .box2&#123; background:red; width:10px; height:10px; margin: 10px; border-radius: 5px; box-shadow: 20px 20px 0 4px green, 40px 20px 0 4px green, 30px 30px 0 -2px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box1"&gt;&lt;/div&gt; &lt;div class="box2"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 利用box-shadow来画哆啦A梦1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; position: relative; width: 36px; height: 36px; border-radius: 50%; margin: 300px auto; background-color: #C63D01; box-shadow: 0px 0px 0 1px #000, -20px -26px 0 -10px #333333, -34px -40px 0 15px #fff, -34px -40px 0 16px, 20px -26px 0 -10px #333333, 34px -40px 0 15px #fff, 34px -40px 0 16px, 0px 55px 0 75px #fff, 0px 55px 0 76px #000, 0 22px 0 120px #08BDEB, 0 22px 0 121px #000; &#125; /*叮当猫的鼻子*/ .container::before&#123; content: ''; position: absolute; bottom: -81px; left: 17px; height: 80px; width: 2px; background-color: #000; &#125; /*叮当猫的嘴巴*/ .container::after&#123; content: ''; position: absolute; bottom: -83px; left: -44px; width: 125px; height: 70px; border-bottom-right-radius: 28px; border-bottom: solid 2px black; border-bottom-left-radius: 28px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; clip-path 对容器进行裁剪 常见的几何图形(圆形、菱形、五角星等等) 可以做iOS的圆角 自定义路径 但是clip-path对有些浏览器的兼容性不是很好 clip-path demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 400px; height: 300px; border: 1px solid red; background:url(./panda.jpg); background-size: cover; background-repeat: no-repeat; background-position: center center; padding:10px; /* 矩形 内部裁剪 */ /* clip-path: inset(100px 50px); */ /* 菱形 */ /* clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); */ /* 圆形 带过渡动画 */ clip-path: circle(50px at 100px 100px); transition:clip-path .4s; /* 五角星 */ /* clip-path: url(#clipPath); */ &#125; .container:hover&#123; clip-path: circle(80px at 100px 100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; 你好，我是熊猫 &lt;/div&gt; &lt;svg&gt; &lt;defs&gt; &lt;clipPath id="clipPath"&gt; &lt;!-- &lt;circle cx="60" cy="60" r="50" fill="#34538b" /&gt; --&gt; &lt;polygon stroke="#979797" points="0.4921875 81.2070313 92.640625 81.2070313 121.601562 0.21875 153.648437 81.2070313 247.390625 80.7734375 173.394531 140.496094 200.308594 227.09375 121.601562 172.71875 53.4960937 227.09375 80.859375 140.496094"&gt;&lt;/polygon&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 2D/3D变换2D变换 transform变换 translate 偏移 scale 缩放 skew 斜切 rotate 旋转 3D变换 demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; margin:50px; padding: 10px; border: 1px solid red; width: 200px; height: 200px; position: relative; perspective: 500px; &#125; #cube&#123; width:200px; height:200px; transform-style: preserve-3d; transform: translateZ(-100px); transition:transform .4s; &#125; #cube div&#123; width: 200px; height:200px; position: absolute; line-height: 200px; font-size:50px; text-align: center; &#125; #cube:hover&#123; /* transform: translateZ(-100px) rotateX(270deg); */ transform: translateZ(-100px) rotateX(90deg) rotateY(90deg); &#125; .front&#123; transform: translateZ(100px); /* transform: translateX(100px); */ /* transform: translateX(100px) translateY(10px) rotate(25deg); */ /* transform: rotate(25deg) translateX(100px) translateY(10px); */ background:rgba(255,0,0,.3); &#125; .back&#123; /* transform: translateZ(-100px); */ transform: translateZ(-100px) rotateY(180deg); background:rgba(0,255,0,.3); &#125; .left&#123; transform: translateX(-100px) rotateY(-90deg); background:rgba(0,0,255,.3); &#125; .right&#123; transform: translateX(100px) rotateY(90deg); background:rgba(255,255,0,.3); &#125; .top&#123; transform: translateY(-100px) rotateX(-90deg); background:rgba(255,0,255,.3); &#125; .bottom&#123; transform: translateY(100px) rotateX(90deg); background:rgba(0,255,255,.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div id="cube"&gt; &lt;div class="front"&gt;1&lt;/div&gt; &lt;div class="back"&gt;2&lt;/div&gt; &lt;div class="right"&gt;3&lt;/div&gt; &lt;div class="left"&gt;4&lt;/div&gt; &lt;div class="top"&gt;5&lt;/div&gt; &lt;div class="bottom"&gt;6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS动画 动画的原理: 视觉暂留作用 画面逐渐变化 动画的作用： 给用户愉悦感 引起用户注意 给用户操作反馈 掩饰后台加载 CSS动画类型 transition补间动画 keyframe关键帧动画 逐帧动画 transition补间动画 过渡动画需要有状态的变化 位置-平移(left/right/margin/transform) 方位-旋转(transform) 大小-缩放(transform) 透明度(opacity) 其它-线性变换(transform) transition demo1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; background: red; /* transition: width 1s, background 3s; transition-delay: 1s; */ transition: all 1s; /* transition-timing-function: ease-in-out; */ transition-timing-function: cubic-bezier(0.465, -0.460, 0.525, 1.435); &#125; .container:hover&#123; width: 800px; background:green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; keyframe关键帧动画 相当于多个补间动画 但它与元素的状态变化无关 定义更加灵活 keyframe demo1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; background: red; animation: run 1s linear; /* 反向动画 */ /* animation-direction: reverse; */ /* 决定动画最后停在哪 */ /* animation-fill-mode: forwards; */ /* 动画次数 infinite为无限执行 */ animation-iteration-count: infinite; /* 播放状态 */ /* animation-play-state: paused; */ &#125; @keyframes run&#123; 0%&#123; width: 100px; &#125; 50%&#123; width: 800px; &#125; 100%&#123; width: 100px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 逐帧动画 其实还是属于关键帧动画的一种 适用于无法补间计算的动画 资源较大 使用steps(x): 指定两个关键帧之间有几个画面 逐帧动画 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!--实现猎豹跑动的动画--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 100px; height: 100px; border: 1px solid red; background: url(./animal.png) no-repeat; animation: run 1s infinite; animation-timing-function: steps(1); &#125; @keyframes run&#123; 0%&#123; background-position: 0 0; &#125; 12.5%&#123; background-position: -100px 0; &#125; 25%&#123; background-position: -200px 0; &#125; 37.5%&#123; background-position: -300px 0; &#125; 50%&#123; background-position: 0 -100px; &#125; 62.5%&#123; background-position: -100px -100px; &#125; 75%&#123; background-position: -200px -100px; &#125; 87.5%&#123; background-position: -300px -100px; &#125; 100%&#123; background-position: 0 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS预处理器CSS预处理器简介 基于CSS的另一种语言 通过工具编译成CSS 添加了很多CSS不具备的特性 能提升CSS文件的组织方式 CSS预处理器特性 嵌套以反映层级和约束 变量和计算以减少重复代码 Extend和Mixin代码片段 循环以适用于复杂有规律的样式 import CSS文件以模块化 CSS预处理器框架 Less - Lesshat/EST SASS - Compass 提供现成的mixin 类似JS类库，封装常用功能 PostCSS后处理器 CSS工程化：组织 优化 构建 维护 PostCSS常见的插件 import 模块合并 将import的语句都内联进来，方便组织更好的代码 autoprefixier 自动加前缀 cssnano 压缩代码，一般放在配置项的最后面 cssnext 使用CSS新特性 precss变量、mixin、循环等等 autoprefixer的配置写法 cssnext precss 和预处理十分相似。 PostCSS支持的构建工具 CLI命令行工具 webpack postcss-loader Gulp gulp-postcss Grunt grunt-postcss Rollup rollup-postcss … webpack JS是整个应用的核心入口 一切资源均由JS管理依赖 一切资源均由webpack打包]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeCodeCamp上面的JS算法题]]></title>
    <url>%2F2017%2F03%2F11%2FFreeCodeCamp%E4%B8%8A%E9%9D%A2%E7%9A%84JS%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Info:Javascript中操作字符串和数组一些常见的方法。 Split Strings with split()12345var string = "Split me into an array";var array = [];array = string.split(" ");console.log(array); //[ 'Split', 'me', 'into', 'an', 'array' ] // split() 方法用于把一个字符串分割成字符串数组。// 提示： 如果把空字符串 (“ “) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。// 注意： split() 方法不改变原始字符串。 Get the sub string with substring/substr/slice()1234567891011var s = 'hello, world'var r1 = s.substring(0, 5); // 从索引0开始到5(不包括5)var r2 = s.substring(7); // 从索引7开始到结束var r3 = s.substr(2,4); //从索引开始找接下来的4个字符var r4 = s.slice(-5);console.log(r1); //helloconsole.log(r2); //worldconsole.log(r3); //llo,console.log(r4); //world Title Case a Sentence with toUpper/LowerCase()12345678910111213141516171819202122// 句中单词首字母大写:function titleCase(str) &#123; // 请把你的代码写在这里 arr = str.split(" "); var newStr = ""; for(var i = 0;i&lt;arr.length;i++)&#123; newStr += arr[i][0].toUpperCase(); for(var j = 1;j&lt;arr[i].length;j++)&#123; newStr += arr[i][j].toLowerCase(); &#125; if(i!=arr.length-1)&#123; newStr += " "; &#125;&#125; return newStr;&#125;var r = titleCase("I'm a little tea pot");console.log(r); //I'm A Little Tea Pot Get the index of string in a stringObj with indexOf/lastIndexOf()123456789var s = 'hello, world';var r1 = s.indexOf('world'); // 找到指定的子串,返回该子串第一次出现的位置var r2 = s.indexOf('sorld'); // 没有找到指定的子串，返回-1var r3 = s.lastIndexOf('l'); // 找到指定的子串，返回该子串最后一次出现的位置console.log(r1); //7console.log(r2); //-1console.log(r3); //10 Iterate over Arrays with map()1234567891011121314151617var oldArray = [1,2,3,4,5];// 只能在这一行下面写代码var newArray = oldArray.map(function(val)&#123; return val + 3;&#125;);console.log(newArray); //[ 4, 5, 6, 7, 8 ]// another// var numbers = [4, 9, 16, 25];// function myFunction() &#123;// x = document.getElementById("demo")// x.innerHTML = numbers.map(Math.sqrt);// &#125; // map() 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。// map() 方法按照原始数组元素顺序依次处理元素。// 注意： map() 不会对空数组进行检测。// 注意： map() 不会改变原始数组。 Condense arrays with reduce()12345678910var array = [4,5,6,7,8];var singleVal = 0;// 只能在这一行下面写代码singleVal = array.reduce(function(pre,cur)&#123; return pre + cur ;&#125;);console.log(singleVal); //30 // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并(迭代)，最终计算为一个值。// 注意: reduce() 对于空数组是不会执行回调函数的。 Filter Arrays with filter()123456789var oldArray = [1,2,3,4,5,6,7,8,9,10];// 只能在这一行下面写代码var newArray = oldArray.filter(function(val)&#123; return val &lt; 6;&#125;);console.log(newArray); //[ 1, 2, 3, 4, 5 ] // filter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。// filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。// 回调函数返回 true 的项会保留在数组中，返回 false 的项会被过滤出数组。 Sort Arrays with sort()1234567var array = [1, 21, 12, 2];array.sort(function(a, b) &#123; return b - a;&#125;); // 将数组元素从大到小排序console.log(array); //[ 21, 12, 2, 1 ] 1234567891011121314151617// 数组排序并找出元素索引:function where(arr, num) &#123; // 请把你的代码写在这里 var newArr = []; newArr = arr.concat(num); newArr.sort(function(a,b)&#123; return a-b; &#125;); for(var i =0;i&lt;newArr.length;i++)&#123; if(newArr[i] === num)&#123; return i;&#125; &#125;&#125;var r = where([40, 60], 50);console.log(r); //1 // sort() 方法将改变原数组，返回被排序后的数组。// sort() 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。// 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 Reverse Arrays with reverse()12345678var array = [1,2,3,4,5,6,7];var newArray = [];// 只能在这一行下面写代码newArray = array.reverse();console.log(newArray); //[ 7, 6, 5, 4, 3, 2, 1 ] // reverse()方法用于颠倒数组中元素的顺序。// reverse()方法会改变原来的数组，而不会创建新的数组。 Concatenate Arrays with concat()12345678var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe);console.log(newArray); //[ 1, 2, 3, 4, 5, 6 ] // concat()方法用于连接两个或多个数组。// concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 Join Strings with join()12345678var joinMe = ["Split","me","into","an","array"];var joinedString = ' ';// 只能在这一行下面写代码joinedString = joinMe.join(joinedString);console.log(joinedString); //Split me into an array // join() 方法用于把数组中的所有元素转换一个字符串。// 元素是通过指定的分隔符进行分隔的。 Find the Longest Word in a String with Math.max.apply()12345678910111213141516171819// 找到字符串中最长的单词function findLongestWord(str) &#123; var maxLength = 0; var arr = []; var s = str.split(" "); console.log(str); for(var i = 0;i&lt;s.length;i++)&#123; arr[i] = s[i].length; &#125; maxLength = Math.max.apply(null,arr); return maxLength;&#125;var r = findLongestWord("The quick brown fox jumped over the lazy dog");console.log(r); //6 //Math.max.apply()方法可以得到数组中最大的数,Math.max.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 Remove the smallest number in an array with splice()123456789function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); //[ 2, 3, 4, 1, 2, 5 ] //splice()方法:arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 es6的find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12345[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 [1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9; &#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。另外，这两个方法都可以发现♂，弥补了数组的IndexOf方法的不足。 1234[NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>algorithm</tag>
        <tag>freecodecamp</tag>
        <tag>array</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【二】]]></title>
    <url>%2F2017%2F03%2F08%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:JS学习的补充笔记，包括JS-Web-Api、事件绑定、事件冒泡、事件代理、AJAX、跨域和存储 日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date(); //Date()是一个构造函数，.now是他的一个属性函数dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月（0 - 11）dt.getDate(); //日（0 - 31）dt.getHours(); //小时（0 - 23）dt.getMinutes(); //分钟（0 - 59）dt.getSeconds(); //秒（0 - 59） MathMath.random()获取随机数 数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否至少有一个元素符合条件 sort 排序 map 对元素重新组装，生成一个新数组 filter 过滤符合条件的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.forEachvar arr = [1,2,3];arr.forEach( function(item, index) &#123; console.log(index,item);// 0 1 1 2 2 3&#125;);// 2.everyvar arr = [1,2,3];var result = arr.every(function(item,index)&#123; if(item &lt; 4)&#123; return true; &#125;&#125;)console.log(result); // true// 3.somevar arr = [1,2,3];var result = arr.some(function(item,index)&#123; if(item &lt; 2)&#123; return true; &#125;&#125;)console.log(result); //true// 4.sortvar arr = [1,4,3,5,2];var arr2 = arr.sort(function(a,b)&#123; return a - b; //从小到大排序&#125;)console.log(arr2); //[1,2,3,4,5]// 5.mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index)&#123; return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;)console.log(arr2); //[ '&lt;b&gt;1&lt;/b&gt;', '&lt;b&gt;2&lt;/b&gt;', '&lt;b&gt;3&lt;/b&gt;', '&lt;b&gt;4&lt;/b&gt;' ]// 6.filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index)&#123; //通过某个条件过滤数组 if(item &gt;= 2)&#123; return true; &#125;&#125;)console.log(arr2); //[2,3] 对象API1234567891011var obj = &#123; x: 100, y: 200, z: 300&#125;var key;for (key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key,obj[key]); &#125;&#125; // x 100 y 200 z 300 事件通用事件绑定123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href="http://baidu.com" id="link1"&gt; &lt;button type="button" id="btn1"&gt;我是按钮&lt;/button&gt; &lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById('btn1'); btn.addEventListener('click', function(event)&#123; console.log('clicked'); &#125;) function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var a = document.getElementById('link1'); bindEvent(a,'click', function(e)&#123; e.preventDefault(); //阻止默认行为 alert('clicked'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); //阻止事件冒泡 alert('激活'); &#125;) bindEvent(body,'click',function(e)&#123; alert('取消'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理 （冒泡的应用）它还有一个名字叫事件委托，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li &#123; display: block; height: 50px; width: 100px; text-align: center; line-height: 50px; background-color: #888; margin-bottom: 8px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="Inul"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //不使用事件委托 /*window.onload = function()&#123; var oUL = document.getElementById("Inul"); var aLi = oUL.getElementsByTagName("li"); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125; &#125;*/ //使用事件委托 window.onload = function () &#123; var oUL = document.getElementById("Inul"); oUL.onclick = function () &#123; alert(123); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代理的两个优点：1.使得代码比较简洁2.给浏览器的压力比较小 AJAXAJAX的全称 Asynchronous Javascript And XML 异步JavaScript和XML XMLHttpRequest123456789101112var xhr = new XMLHttpRequest()xhr.open("GET","/api",true)xhr.onreadystatechange = function () &#123; // 第三个参数为true,这里的函数为异步执行 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) 跨域什么是跨域 可以跨域的三个标签但是有三个标签可以跨域加载资源 &lt;img src = “XXX”&gt; （图片） &lt;link herf = “XXX”&gt; （CSS） &lt;script src = “XXX”&gt; （JS） 这三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN，CDN的也是其他域 &lt;script&gt;可以用于JSONP 跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许就能够获取到，那就是浏览器的同源策略出现了漏洞 解决跨域的方法 JSONP JSONP的工作原理： 很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如：&lt;script src=”http://www.example.net/api?param1=1&amp;param2=2&quot;&gt; &lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）形如:callback({“name”:”hax”,”gender”:”Male”})。 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。 服务器端设置 http header（即CORS（跨域资源共享）） 存储 cookie localStorage 和 sessionStorage cookie与webStorage的区别]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>js-web-api</tag>
        <tag>ajax</tag>
        <tag>事件</tag>
        <tag>跨域</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【一】]]></title>
    <url>%2F2017%2F03%2F06%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:之前JS学习的一些笔记，包括JS变量类型以及JS的三个重点：原型和原型链、作用域与闭包、异步和单线程 变量类型和计算引用类型（3种）对象、数组、函数。 引用类型的内存只存一份，而值类型是存多份 引用类型可以无限扩展属性 typeof（6种）undefined、number、string、boolean、object、function。 强制类型转换 字符串拼接； ==运算符； if条件语句； 逻辑运算（与或非)。 何时使用==if(obj.a == null){ … } //这里是简写，相当于obj.a === null || obj.a === undefined。其他时候全部用三等“===”。 if(…){ }条件为假的几种情况 0； NaN； “”; null; undefined; false。 JS中的内置函数（数据封装内对象） Object； Array； Boolean； Number； String； Function； Date； RegExp； Error。 如何理解JSON JSON.stringify({a:10,b:20}); // 把对象变成字符串 JSON.parse(‘{“a”:10,”b”:20}’)。 // 把字符串变成对象 （JSON只不过是一个JS对象）上面就是JSON常见的两个API。 原型与原型链构造函数12345678910111213function Foo(name,age)&#123; //构造函数首字母大写 this.name = name; this.age = age; this.class = 'class-1'; //return this; //返回这个对象&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);console.log(f); //Foo &#123; name: 'zhangsan', age: 20, class: 'class-1' &#125;console.log(f instanceof Object); //true 构造函数—拓展 var a = { } 其实是var a = new Object()的语法糖； var a = [ ] 其实是var a = new Array()的语法糖； function Foo(){…} 其实是var Foo = new Function()的语法糖； 使用instanceof判断一个函数是否是一个变量的构造函数。 原型规则和示例 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由拓展属性（除了”null”之外）； 所有的引用类型（对象、数组、函数）都有一个__proto__（隐式原型）属性，属性值是一个普通的对象； 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象； 所有的引用类型（对象、数组、函数），__proto__属性值指向它的构造函数的prototype属性值； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。 123456789101112131415//第一条规则：var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn()&#123;&#125;; fn.a = 100;//第二条规则：console.log(obj.__proto__); //&#123;&#125;console.log(arr.__proto__); //[]console.log(fn.__proto__); //[Function]//第三条规则：console.log(fn.prototype); //fn &#123;&#125;//第四条规则：console.log(obj.__proto__ === Object.prototype); //true 12345678910111213141516171819202122// 第五条规则：// 构造函数function Foo (name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function()&#123; alert(this.name);&#125;// 创建示例var f = new Foo('zhangsan');f.printName = function () &#123; console.log(this.name);&#125;// 测试f.printName(); //zhangsanf.alertName(); //zhangsanf.toString(); //要去 f.__proto__.__proto__中去寻找//console.log(f.__proto__.__proto__.__proto__); //null 补充： 12345678var item;for(item in f)&#123; // 虽然高级浏览器已经在 for in 中屏蔽了来自原型的属性 // 但是还是建议加上这个判断，保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item); &#125;&#125; 原型链 instanceof用于判断引用类型属于那个构造函数的方法。 关于原型和原型链的几个问题1.如何准确判断一个变量是数组类型： 123var arr = [];arr instanceof Array; //truetypeof arr; //Object(typeof是无法准确判断是否是数组的 2.写一个原型链继承的例子： 12345678910111213141516171819202122232425//普通版：// 动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125;// 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat() 12345678910111213141516171819202122232425262728293031323334//高级版（写一个封装DOM查询的例子）：function Elem (id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val)&#123; var elem = this.elem; if(val)&#123; elem.innerHTML = val; return this; //链式操作 &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function (type,fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem('div1');// console.log(div.html())div1.html('&lt;p&gt;hello world&lt;/p&gt;');div1.on('click',function () &#123; alert('clicked!');&#125;)//因为有第十行的“return this”（返回的是this这个对象），所以可以进行链式操作：// div1.html('&lt;p&gt;hello world&lt;/p&gt;').on('click',function()&#123;// alert('clicked!');// &#125;); 3.描述new一个变量的过程： 即考察对构造函数的理解。 创建一个新对象； this指向这个对象； 执行代码，即对this赋值； 返回this。 4.zepto（或其他框架）源码中如何使用原型链： zepto设计和源码分析 作用域与闭包执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 （一段&lt;script&gt;） 函数：变量定义、函数声明、this、arguments （一个函数） 123456789console.log(a); //undefinedvar a = 100;fn('zhangsan');function fn (name) &#123; age = 20; console.log(name,age); //zhangsan 20 var age;&#125; this this要在执行时才能确认值，定义时无法确认。 作为构造函数执行； 作为对象属性执行； 作为普通函数执行； call()、apply()、bind()； 1234567891011121314151617181920212223242526272829303132333435363738394041//1.作为构造函数执行function Foo (name) &#123; this.name = name;&#125;var f = new Foo('zhangsan');//2.作为对象属性执行var obj = &#123; name: 'A', printName: function () &#123; console.log(this.name); &#125;&#125;obj.printName(); //A (this ===obj)//3.作为普通函数执行function fn()&#123; console.log(this);&#125;fn(); ///undefined (this === window)//4.call和apply（都用来改变this的值，call在实际工作中用的更多,两者传参方式不一样，apply用数组格式）function fn1(name,age)&#123; alert(name) alert(age) console.log(this)&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22)//bind（同样用来改变this的值，注意函数声明要用函数表达式的方式）var fn2 = function (name,age)&#123; alert(name) alert(age) console.log(this)&#125;.bind(&#123;x:100&#125;)fn2('zhangsan',22) 作用域 JS没有块级作用域； 只有函数和全局作用域； 1234567891011121314// 无块级作用域if(true)&#123; var name = 'zhangsan';&#125; //大括号相当于一个块console.log(name); //zhangsan// 函数和全局作用域var a = 100;function fn () &#123; var a = 200; console.log('fn',a);&#125;fn(); //fn 200console.log('global',a); //global 100 作用域链1234567891011121314var a = 100;function fn1 () &#123; var b =200; function fn2 () &#123; var c = 300; //当前作用域没有定义的变量，即“自由变量”，自由变量要去声明时候的作用域去找，而不是执行时候的作用域 console.log(a); //a是自由变量，则要到当前fn2作用域的父级作用域去找，没有找到，则继续到fn1的父级作用域去找 console.log(b); //b是自由变量，则要到当前fn2作用域的父级作用域去找，即fn1的作用域，找到了 console.log(c); &#125; fn2();&#125;fn1(); //100 200 300 闭包闭包的使用场景 函数作为返回值； 函数作为参数传递； 123456789101112// 1.函数作为返回值： function fn1 () &#123; var a = 100; return function () &#123; // 返回一个函数（函数作为返回值） console.log(a); // 自由变量，父作用域查找 &#125;&#125;// fn1得到一个函数var f1 = fn1();var a = 200;f1(); //100 123456789101112131415// 2.函数作为参数传递function fn1 () &#123; var a = 100; return function () &#123; console.log(a); &#125;&#125;var f1 = fn1();function fn2 (fn) &#123; //函数作为参数传递 var a = 200; fn()&#125;fn2(f1); //100 闭包的示例12345678910111213141516171819202122// 1.查询是否是第一次载入：// 闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad () &#123; var _list = []; return function (id) &#123; if(_list.indexOf(id) &gt;= 0)&#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;// 使用var firstLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true// 在isFirstLoad函数外面，根本不可能改掉_list的值 123456789101112131415// 2.创建10个a标签，点击弹出相应的序号：var i;for(i = 0;i &lt; 10;i++)&#123; (function (i)&#123; // 自执行函数，就是不用调用，只要定义完成，立刻执行的函数 // 函数作用域 var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function(e)&#123; e.preventDefault(); alert(i); //自由变量，要去父级作用域获取值 &#125;) document.body.appendChild(a); &#125;)(i)&#125; 异步和单线程什么是异步（对比同步）1234567891011// 异步：console.log(100);setTimeout(function()&#123; console.log(200);&#125;,1000)console.log(300); //先打印100，然后打印300，过一秒钟再打印200// 对比同步：console.log(100);alert(200); //程序阻塞在这里，如果不点击确认就会卡在这里console.log(300); 何时需要异步 在可能发生等待的情况； 等待过程中不能像alert一样阻塞程序的执行； 因此，所有“等待的情况”都需要异步； //并非“阻塞的情况” 前端使用异步的场景 定时任务：setTimeout、setInterval； 网络请求：ajax请求、es6中的promise、动态&lt;img&gt;加载； 事件绑定； setTimeout(表达式,延时时间)和setInterval(表达式,延时时间)经常被用来处理延时和定时任务。setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。 很多人会将setTimeout包含于被执行函数中,然后在函数外再次使用setTimeout来达到定时执行的目的。这样,函数外的setTimeout在执行函数时再次触发setTimeout从而形成周而复始的定时效果； 使用的时候各有各的优势，使用setInterval，需要手动的停止tick触发。而使用方法中嵌套setTimeout，可以根据方法内部本身的逻辑不再调用setTimeout就等于停止了触发。其实两个东西完全可以相互模拟，具体使用那个，看当时的需要而定了。 12345678910111213141516171819202122// ajax请求代码示例：console.log('start');$.get('./datta1.json',function(data1)&#123; console.log(data1);&#125;)console.log('end');// &lt;img&gt;加载示例：console.log('start');var img = document.createElement('img');img.onload = function()&#123; console.log('loaded');&#125;img.src = '/xxx.img';console.log('end');// 事件绑定示例：console.log('start');document.getElementById('btn1').addEventListener('click', function()&#123; alert('clicked');&#125;)console.log('end'); 异步和单线程1234567891011// 单线程：一次只能干一件事，一个一个排队来console.log(100);setTimeout(function()&#123; console.log(200);&#125;)console.log(300);// 1. 执行第一行，打印100；// 2. 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）；// 3. 执行最后一行，打印300；// 4. 待所有的程序执行完，处于空闲状态时，会立马看有没有暂存起来的需要执行；// 5. 发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行； 关于异步和单线程的几个问题 同步和异步的区别是什么。分别举一个同步和异步的例子： 同步会阻塞代码执行，而异步不会； alert是同步，setTimeout是异步。 一个关于setTimeout的笔试题： 12345678910console.log(1);setTimeout(function()&#123; console.log(2)&#125;,0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;,1000);console.log(5);// result: 1 3 5 2 4]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>异步</tag>
        <tag>JS变量类型</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
        <tag>share</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.js的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在对着别人的“5分钟 就能搭建好免费个人博客”教程，折腾了好几个小时，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>note</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
