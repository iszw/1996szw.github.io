<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue2.0搭建旅游网站开发笔记]]></title>
    <url>%2F2018%2F03%2F14%2FVue2.0%E6%90%AD%E5%BB%BA%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Info: Vue开发旅游网站笔记整理 前言这是最近使用Vue写的仿去哪儿网旅游网站，大致实现了网站首页Header制作、首页轮播、图标区块、热销推荐、使用axios获取接口数据、首页父子组件间的传递、城市选择页面路由配置、搜索框布局、better-scroll的使用及字母表布局、搜索的逻辑实现、Vuex实现数据共享、LocalStorage实现页面数据持久存储、使用keep-alive优化路由页面性能、动态路由配置及banner布局、公用画廊组件的拆分、渐隐渐显的header效果实现、递归组件实现详情列表、画廊动画效果封装等实用性网站功能。 在此要十分感谢Vue框架的作者Evan You，这种渐进式的开发方式的确十分的友好，也让人深刻地领会到组件化开发所带来的便捷之处。 而本篇文章是作为整个项目开发时的一些记录，以便日后完善或者重构代码时能够更加清晰。 项目源码：https://github.com/1996szw/TravelWeb 使用方式： 1234567891011# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report 项目代码初始化配置移动端的&lt;meta&gt;标签12&lt;!-- 设置移动端屏幕比例不可缩放 --&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; 引入reset.css在不同的移动设备上，浏览器的初始样式表是不统一的。所以需要引入reset.css来进行统一化，之后在项目入口文件main.js中引用该样式表：import &#39;styles/reset.css&#39; 1234567891011121314151617181920212223242526/* 重置样式表reset.css */@charset "utf-8";html&#123;background-color:#fff;color:#000;font-size:12px&#125;body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp&#123;margin:0;padding:0&#125;body,input,textarea,button,select,pre,xmp,tt,code,kbd,samp&#123;line-height:1.5;font-family:tahoma,arial,"Hiragino Sans GB",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select&#123;font-size:100%&#125;h1,h2,h3,h4,h5,h6&#123;font-family:tahoma,arial,"Hiragino Sans GB","微软雅黑",simsun,sans-serif&#125;h1,h2,h3,h4,h5,h6,b,strong&#123;font-weight:normal&#125;address,cite,dfn,em,i,optgroup,var&#123;font-style:normal&#125;table&#123;border-collapse:collapse;border-spacing:0;text-align:left&#125;caption,th&#123;text-align:inherit&#125;ul,ol,menu&#123;list-style:none&#125;fieldset,img&#123;border:0&#125;img,object,input,textarea,button,select&#123;vertical-align:middle&#125;article,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu&#123;display:block&#125;audio,canvas,video&#123;display:inline-block;*display:inline;*zoom:1&#125;blockquote:before,blockquote:after,q:before,q:after&#123;content:"\0020"&#125;textarea&#123;overflow:auto;resize:vertical&#125;input,textarea,button,select,a&#123;outline:0 none;border: none;&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;padding:0;border:0&#125;mark&#123;background-color:transparent&#125;a,ins,s,u,del&#123;text-decoration:none&#125;sup,sub&#123;vertical-align:baseline&#125;html &#123;overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;&#125;body &#123;font-family: Arial, "Microsoft Yahei", "Helvetica Neue", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;&#125;hr &#123;height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;&#125;a &#123;color: #25a4bb;text-decoration: none;&#125; 解决移动设备中的一像素边框问题有的移动设备分辨率比较高是一个二倍屏或是三倍屏，所以在写1像素边框的时候，写的是1px但实际渲染出来却是2px或是3px。所以需要引入一个1像素边框的解决方案:import &#39;styles/border.css&#39; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/* 1像素边框的解决方案border.css *//* 该代码解决方式是css中的scale */@charset "utf-8";.border,.border-top,.border-right,.border-bottom,.border-left,.border-topbottom,.border-rightleft,.border-topleft,.border-rightbottom,.border-topright,.border-bottomleft &#123; position: relative;&#125;.border::before,.border-top::before,.border-right::before,.border-bottom::before,.border-left::before,.border-topbottom::before,.border-topbottom::after,.border-rightleft::before,.border-rightleft::after,.border-topleft::before,.border-topleft::after,.border-rightbottom::before,.border-rightbottom::after,.border-topright::before,.border-topright::after,.border-bottomleft::before,.border-bottomleft::after &#123; content: "\0020"; overflow: hidden; position: absolute;&#125;/* border * 因，边框是由伪元素区域遮盖在父级 * 故，子级若有交互，需要对子级设置 * 定位 及 z轴 */.border::before &#123; box-sizing: border-box; top: 0; left: 0; height: 100%; width: 100%; border: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-bottom::before,.border-topbottom::before,.border-topbottom::after,.border-topleft::before,.border-rightbottom::after,.border-topright::before,.border-bottomleft::before &#123; left: 0; width: 100%; height: 1px;&#125;.border-right::before,.border-left::before,.border-rightleft::before,.border-rightleft::after,.border-topleft::after,.border-rightbottom::before,.border-topright::after,.border-bottomleft::after &#123; top: 0; width: 1px; height: 100%;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; border-top: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-right::before,.border-rightbottom::before,.border-rightleft::before,.border-topright::after &#123; border-right: 1px solid #eaeaea; transform-origin: 100% 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::before &#123; border-bottom: 1px solid #eaeaea; transform-origin: 0 100%;&#125;.border-left::before,.border-topleft::after,.border-rightleft::after,.border-bottomleft::after &#123; border-left: 1px solid #eaeaea; transform-origin: 0 0;&#125;.border-top::before,.border-topbottom::before,.border-topleft::before,.border-topright::before &#123; top: 0;&#125;.border-right::before,.border-rightleft::after,.border-rightbottom::before,.border-topright::after &#123; right: 0;&#125;.border-bottom::before,.border-topbottom::after,.border-rightbottom::after,.border-bottomleft::after &#123; bottom: 0;&#125;.border-left::before,.border-rightleft::before,.border-topleft::after,.border-bottomleft::before &#123; left: 0;&#125;@media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) &#123; /* 默认值，无需重置 */&#125;@media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) &#123; .border::before &#123; width: 200%; height: 200%; transform: scale(.5); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.5); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.5); &#125;&#125;@media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) &#123; .border::before &#123; width: 300%; height: 300%; transform: scale(.33333); &#125; .border-top::before, .border-bottom::before, .border-topbottom::before, .border-topbottom::after, .border-topleft::before, .border-rightbottom::after, .border-topright::before, .border-bottomleft::before &#123; transform: scaleY(.33333); &#125; .border-right::before, .border-left::before, .border-rightleft::before, .border-rightleft::after, .border-topleft::after, .border-rightbottom::before, .border-topright::after, .border-bottomleft::after &#123; transform: scaleX(.33333); &#125;&#125; 解决移动端的点击300ms延时的问题在项目中，尤其是移动项目中在某些机型、某些浏览器上使用click事件的时候，这些click事件会延迟300ms才会执行，导致用户体验不佳，所以需要引入fastclick第三方库:npm install fastclick --save，然后在main.js中引用并使用这个库: 123import fastClick from 'fastclick'fastClick.attach(document.body) 网站首页的开发移动项目的开发中使用rem如果设计师给的是二倍屏中的86像素，对应就是一倍屏中的43像素，而reset.css中将html{font-size: 50px}，那么就有：1rem = html font size = 50px。所以43px = .86rem 使用css预处理器stylus中的贯穿式变量如果在样式中某一个颜色代码或者尺寸数字会被经常使用到，那么可以在styles文件夹下写一个varibles.styl文件专门用来存放这些个变量，然后在对应的css中引用：@import &#39;../../../assets/styles/varilbes.styl&#39;。这样写引用太复杂了，所以可以在webpack.base.conf.js中将styles目录设置一个别名: 123456789resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'styles': resolve('src/assets/styles'), 'common': resolve('src/common') &#125; &#125;, 使用占位来解决图片还未加载时候高度为0之后会有一个抖动的问题给该图片区域包裹一层&lt;div&gt;标签，然后设置该区块的宽度为100%，而它的高度会根据宽度自动地撑开31.25%: 12345.wrapper overflow hidden width 100% height 0 padding-bottom 31.25% css中的样式穿透当需要设置scoped外其它组件中的元素样式时，需要使用&gt;&gt;&gt;来进行一个样式穿透: 123456789101112131415161718192021.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background #fff``` ## 使用vue-awesome-swiper来显示icon轮播效果时翻页的算法```javascript// 借助computed计算属性computed: &#123; pages () &#123; const pages = [] this.iconList.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8) if (!pages[page]) &#123; pages[page] = [] &#125; pages[page].push(item) &#125;) return pages &#125; &#125; 使用css预处理器stylus中的混合书写Mixins提供…占位符来表示由于空间不够而被隐藏的内容，可以使用stylus中将该方法封装成mixins.styl，然后在需要的地方调用：ellipsis() 1234ellipsis() overflow hidden white-space nowrap text-overflow ellipsis 在vue中使用axios1234567891011121314151617181920212223242526import axios from 'axios'methods: &#123; getHomeInfo () &#123; axios.get('/api/index.json?city=' + this.city) .then(this.getHomeInfoSucc) // axios返回的是一个promise对象，所以可以调用.then方法 &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.weekendList &#125; &#125;&#125;mounted () &#123; this.getHomeInfo()&#125;activated () &#123; this.getHomeInfo()&#125; 城市选择页面开发better-scroll的使用better-scroll是iscroll的一个封装，使用起来要更为友好。若要使用这个包，先要用npm安装:npm install better-scroll --save。然后html代码需要符合如下结构： 12345678&lt;div class="wrapper"&gt; &lt;ul class="content"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;!-- you can put some other DOMs here, it won't affect the scrolling --&gt;&lt;/div&gt; 在上面的代码中，better-scroll应用于外部wrapper容器，滚动部分是content元素。注意，better-scroll只处理容器（wrapper）的第一个子元素（内容）的滚动，这意味着将忽略其他元素。最简单的初始化代码如下： 1234import BScroll from 'beetter-scroll'const wrapper = document.querySelector('wrapper')const scroll = new BScorll(wrapper) better-scroll提供了一个类，其实例化时其第一个参数是普通DOM对象。当然，better-scroll内部会尝试使用querySelector来获取DOM对象，因此initiazation代码也可以如下所示： 123import BScroll from 'better-scroll'const scroll = new BScroll('.wrapper') 获取拖拽动作最后得到的内容并做一个函数节流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class="list"&gt; &lt;ul&gt; &lt;li class="item" v-for="item of letters" :key="item" :ref="item" @click="handleLetterClick" @touchstart.prevent="handleTouchStart" @touchmove="handleTouchMove" @touchend="handleTouchEnd" &gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'CityAlphabet', props: &#123; cities: Object &#125;, data () &#123; return &#123; touchStatus: false, startY: 0, timer: null &#125; &#125;, updated () &#123; this.startY = this.$refs['A'][0].offsetTop &#125;, computed: &#123; letters () &#123; const letters = [] for (let i in this.cities) &#123; letters.push(i) &#125; return letters &#125; &#125;, methods: &#123; handleLetterClick (e) &#123; this.$emit('change', e.target.innerText) &#125;, handleTouchStart () &#123; this.touchStatus = true &#125;, handleTouchMove (e) &#123; if (this.touchStatus) &#123; if (this.timer) &#123; // 函数节流 clearTimeout(this.timer) &#125; this.timer = setTimeout(() =&gt; &#123; const touchY = e.touches[0].clientY - 75 const index = Math.floor((touchY - this.startY) / 18) if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index]) &#125; &#125;, 16) &#125; &#125;, handleTouchEnd () &#123; this.touchStatus = false &#125; &#125;&#125;&lt;/script&gt; 使用vuex来实现数据共享Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。在Vue的大型项目开发之中，Vue.js只能承担视图层的主要内容，而当涉及到大量数据间的传递，往往都要通过vuex这个数据框架来完成。虽然bus总线的作法有时候也可以完成效果，但写起来还是比较麻烦。 Vuex其实就是一个单向数据的改变流程。使用vuex需要先安装vuex：npm install vuex --save，之后要在项目的入口文件main.js中引入这个包并在创建根实例的时候把store传递进去来使用： 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; city: '杭州' &#125;, actions: &#123; changeCity (ctx, city) &#123; // ctx是一个上下文，可以通过它来执行commit方法 ctx.commit('changeCity', city) &#125; &#125;, mutations: &#123; changeCity (state, city) &#123; state.city = city &#125; &#125;,&#125;) vuex中的map映射api在每次调用vuex公用数据中的city的时候，都要写this.$store.state.city这样的一串，而vuex就提供了一个map映射api来简化这样的代码，先要引入需要映射的数据，然后通过...扩展运算符将state里面的city映射到HomeHeader这个组件的computed计算属性中，然后就可以直接通过this.city来调用这个数据了(如果是mutations则可以映射到组件的methods方法中) 12345678import &#123; mapState &#125; from 'vuex'export default &#123; name: 'HomeHeader', computed: &#123; ...mapState(['city']) &#125;&#125; vuex中的getter和modulevuex中的getter很类似于组件中的computed计算属性，如果需要根据vuex的state里的数据来计算出一个新的数据的时候，就可以通过getter来进行实现，从而避免数据的冗余。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 vue中的内置组件&lt;keep-alive&gt;&lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和&lt;transition&gt;相似，&lt;keep-alive&gt;是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中。 &lt;keep-alive&gt;可以接受可选参数： include - 字符串或正则表达式。只有匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何匹配的组件都不会被缓存。 当组件在&lt;keep-alive&gt;内被切换，它的activated和deactivated这两个生命周期钩子函数将会被对应执行。 123456789101112131415methods: &#123; getDetailInfo () &#123; axios.get('/api/detail.json', &#123; params: &#123; id: this.$route.params.id &#125; &#125;).then(this.handleGetDataSucc) &#125;&#125; mounted () &#123; this.getDetailInfo() &#125;, activated () &#123; this.getDetailInfo() // 每次页面被加载的时候，都重新发送一个ajax请求 &#125; 详情页面的开发动态路由&lt;router-link&gt;标签的to前面可以跟一个:来作一个动态路由，这样就可以传递出一个参数给router。调用这个参数可以通过this.$router.params.id 12345678910111213141516&lt;ul&gt; &lt;router-link tag="li" class="item border-bottom" v-for="item of recommendList" :key="item.id" :to="'/detail/' + item.id" &gt; &lt;img class="item-img" :src="item.imgUrl" /&gt; &lt;div class="item-info"&gt; &lt;p class="item-title"&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;p class="item-desc"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/p&gt; &lt;button class="item-btn"&gt;查看详情&lt;/button&gt; &lt;/div&gt; &lt;/router-link&gt;&lt;/ul&gt; 给DOM元素添加一个渐变的边框12.banner-info background-image linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, .5)) 实现顶部Header区域拖动渐隐渐现效果如果通过给window对象绑定一个全局事件的方式来实现某个功能，那么要记得及时地对这个全局事件进行一个解绑，否则就会影响外部组件。 12345678910111213141516171819202122232425262728name: 'DetailHeader',data () &#123; return &#123; showAbs: true, opacityStyle: &#123; opacity: 0 &#125; &#125;&#125;,methods: &#123; handleScroll () &#123; const top = document.documentElement.scrollTop if (top &gt; 60) &#123; let countOpacity = top / 140 countOpacity = countOpacity &gt; 1 ? 1 : countOpacity this.opacityStyle.opacity = countOpacity this.showAbs = false &#125; else &#123; this.showAbs = true &#125; &#125;&#125;,activated () &#123; window.addEventListener('scroll', this.handleScroll)&#125;,deactivated () &#123; // 使用deactivated来对全局事件进行解绑，当退出这个页面时，此函数会被执行 window.removeEventListener('scroll', this.handleScroll)&#125; 递归组件在组件模板中调用组件的自身就叫做递归组件。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;div class="item" v-for="(item, index) of list" :key="index"&gt; &lt;div class="item-title border-bottom"&gt; &lt;span class="item-title-icon"&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if="item.children" class="item-children"&gt; &lt;detail-list :list="item.children"&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'DetailList', data: &#123; list: [ &#123; title: '我是一级标题', children: [&#123; title: '我是二级标题', children: [&#123; title: '我是三级标题' &#125;] &#125;] &#125;, &#123; title: '我是一级标题', children: [ &#123; title: '我是二级标题' &#125; ] &#125;, &#123; title: '我是一级标题' &#125; ]&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>stylus</tag>
        <tag>travelweb</tag>
        <tag>vue-awesome-swiper</tag>
        <tag>axios</tag>
        <tag>better-scroll</tag>
        <tag>vuex</tag>
        <tag>localstorge</tag>
        <tag>keep-alive</tag>
        <tag>vue-router</tag>
        <tag>动态路由</tag>
        <tag>父子组件间传递数据</tag>
        <tag>递归组建</tag>
        <tag>移动开发</tag>
        <tag>reset.css</tag>
        <tag>1像素边框</tag>
        <tag>300ms点击延时</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【毕设】数据挖掘算法之Apriori关联规则挖掘]]></title>
    <url>%2F2018%2F01%2F12%2F%E3%80%90%E6%AF%95%E8%AE%BE%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95%E4%B9%8BApriori%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[Info: Apriori关联规则算法学习 步入大四，毕设也是今年的重中之重，学校给我分配的课题是《基于大数据平台的关联规则算法的研究与实现》。之前没有接触过大数据的我也是要从头开始相关的学习，比如Hadoop的配置、关联规则算法的python实现、还有如何将Apriori算法在MapReduce上面并行化。本文就是关联规则算法的相关介绍。 另外也要感谢我校嵌入式研究中心的主任李超老师，给我提供了性能可靠的物理服务器来进行该课题的研究。 关联分析关联分析是一种在大规模数据集中寻找有趣关系的任务。这些关系可以有两种形式: 频繁项集（frequent item sets）: 经常出现在一块的物品的集合。 关联规则（associational rules）: 暗示两种物品之间可能存在很强的关系。 相关术语 关联分析（关联规则学习): 从大规模数据集中寻找物品间的隐含关系被称作 关联分析(associati analysis) 或者 关联规则学习（association rule learning） 。 下面是用一个 杂货店 例子来说明这两个概念，如下图所示: 频繁项集: {葡萄酒, 尿布, 豆奶} 就是一个频繁项集的例子。 关联规则: 尿布 -&gt; 葡萄酒 就是一个关联规则。这意味着如果顾客买了尿布，那么他很可能会买葡萄酒。 那么 频繁 的定义是什么呢？怎么样才算频繁呢？度量它们的方法有很多种，这里我们来简单的介绍下支持度和置信度。 支持度: 数据集中包含该项集的记录所占的比例。例如上图中，{豆奶} 的支持度为 4/5。{豆奶, 尿布} 的支持度为 3/5。 置信度: 针对一条诸如 {尿布} -&gt; {葡萄酒} 这样具体的关联规则来定义的。这条规则的 置信度 被定义为 支持度({尿布, 葡萄酒})/支持度({尿布})，从图中可以看出 支持度({尿布, 葡萄酒}) = 3/5，支持度({尿布}) = 4/5，所以 {尿布} -&gt; {葡萄酒} 的置信度 = 3/5 / 4/5 = 3/4 = 0.75。 支持度 和 置信度 是用来量化 关联分析 是否成功的一个方法。假设想找到支持度大于 0.8 的所有项集，应该如何去做呢？一个办法是生成一个物品所有可能组合的清单，然后对每一种组合统计它出现的频繁程度，但是当物品成千上万时，上述做法就非常非常慢了。我们需要详细分析下这种情况并讨论下 Apriori 原理，该原理会减少关联规则学习时所需的计算量。 Apriori 原理假设我们一共有 4 个商品: 商品0, 商品1, 商品2, 商品3。所有可能的情况如下:如果我们计算所有组合的支持度，也需要计算 15 次。即 2^N - 1 = 2^4 - 1 = 15。随着物品的增加，计算的次数呈指数的形式增长 … 为了降低计算次数和时间，研究人员发现了一种所谓的 Apriori 原理，即某个项集是频繁的，那么它的所有子集也是频繁的。例如，如果 {0, 1} 是频繁的，那么 {0}, {1} 也是频繁的。 该原理直观上没有什么帮助，但是如果反过来看就有用了，也就是说如果一个项集是 非频繁项集，那么它的所有超集也是非频繁项集，如下图所示: 在图中我们可以看到，已知灰色部分 {2,3} 是 非频繁项集，那么利用上面的知识，我们就可以知道 {0,2,3} {1,2,3} {0,1,2,3} 都是 非频繁的。也就是说，计算出 {2,3} 的支持度，知道它是 非频繁 的之后，就不需要再计算 {0,2,3} {1,2,3} {0,1,2,3} 的支持度，因为我们知道这些集合不会满足我们的要求。使用该原理就可以避免项集数目的指数增长，从而在合理的时间内计算出频繁项集。 Apriori 算法优缺点 123* 优点：易编码实现* 缺点：在大数据集上可能较慢* 适用数据类型：数值型 或者标准型数据。 Apriori 算法流程步骤： 123456* 收集数据：使用任意方法。* 准备数据：任何数据类型都可以，因为我们只保存集合。* 分析数据：使用任意方法。* 训练数据：使用Apiori算法来找到频繁项集。* 测试算法：不需要测试过程。* 使用算法：用于发现频繁项集以及物品之间的关联规则。 Apriori 算法的使用前面提到，关联分析的目标包括两项: 发现 频繁项集 和发现 关联规则。首先需要找到 频繁项集，然后才能发现 关联规则。Apriori 算法是发现 频繁项集 的一种方法。Apriori 算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个物品的项集列表。接着扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度要求的集合会被去掉。然后对生下来的集合进行组合以生成包含两个元素的项集。接下来再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集被去掉。 生成候选项集下面会创建一个用于构建初始集合的函数，也会创建一个通过扫描数据集以寻找交易记录子集的函数，数据扫描的伪代码如下: 对数据集中的每条交易记录 tran 对每个候选项集 can 检查一下 can 是否是 tran 的子集: 如果是则增加 can 的计数值 对每个候选项集 can 如果其支持度不低于最小值，则保留该项集 返回所有频繁项集列表 以下是一些辅助函数。 加载数据集123# 加载数据集def loadDataSet(): return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]] 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset1234567891011121314151617181920212223# 创建集合 C1。即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozensetdef createC1(dataSet): """createC1（创建集合 C1） Args: dataSet 原始数据集 Returns: frozenset 返回一个 frozenset 格式的 list """ C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: # 遍历所有的元素，如果不在 C1 出现过，那么就 append C1.append([item]) # 对数组进行 `从小到大` 的排序 print 'sort 前=', C1 C1.sort() # frozenset 表示冻结的 set 集合，元素无改变；可以把它当字典的 key 来使用 print 'sort 后=', C1 print 'frozenset=', map(frozenset, C1) return map(frozenset, C1) 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据1234567891011121314151617181920212223242526272829303132333435# 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度（minSupport）的数据def scanD(D, Ck, minSupport): """scanD（计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于最小支持度 minSupport 的数据） Args: D 数据集 Ck 候选项集列表 minSupport 最小支持度 Returns: retList 支持度大于 minSupport 的集合 supportData 候选项集支持度数据 """ # ssCnt 临时存放选数据集 Ck 的频率. 例如: a-&gt;10, b-&gt;5, c-&gt;8 ssCnt = &#123;&#125; for tid in D: for can in Ck: # s.issubset(t) 测试是否 s 中的每一个元素都在 t 中 if can.issubset(tid): if not ssCnt.has_key(can): ssCnt[can] = 1 else: ssCnt[can] += 1 numItems = float(len(D)) # 数据集 D 的数量 retList = [] supportData = &#123;&#125; for key in ssCnt: # 支持度 = 候选项（key）出现的次数 / 所有数据集的数量 support = ssCnt[key]/numItems if support &gt;= minSupport: # 在 retList 的首位插入元素，只存储支持度满足频繁项集的值 retList.insert(0, key) # 存储所有的候选项（key）和对应的支持度（support） supportData[key] = support return retList, supportData 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 组织完整的 Apriori 算法输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ck12345678910111213141516171819202122232425262728293031# 输入频繁项集列表 Lk 与返回的元素个数 k，然后输出所有可能的候选项集 Ckdef aprioriGen(Lk, k): """aprioriGen（输入频繁项集列表 Lk 与返回的元素个数 k，然后输出候选项集 Ck。 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; 仅需要计算一次，不需要将所有的结果计算出来，然后进行去重操作 这是一个更高效的算法） Args: Lk 频繁项集列表 k 返回的项集元素个数（若元素的前 k-2 相同，就进行合并） Returns: retList 元素两两合并的数据集 """ retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[: k-2] L2 = list(Lk[j])[: k-2] # print '-----i=', i, k-2, Lk, Lk[i], list(Lk[i])[: k-2] # print '-----j=', j, k-2, Lk, Lk[j], list(Lk[j])[: k-2] L1.sort() L2.sort() # 第一次 L1,L2 为空，元素直接进行合并，返回元素两两合并的数据集 # if first k-2 elements are equal if L1 == L2: # set union # print 'union=', Lk[i] | Lk[j], Lk[i], Lk[j] retList.append(Lk[i] | Lk[j]) return retList 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。1234567891011121314151617181920212223242526272829303132333435363738394041# 找出数据集 dataSet 中支持度 &gt;= 最小支持度的候选项集以及它们的支持度。即我们的频繁项集。def apriori(dataSet, minSupport=0.5): """apriori（首先构建集合 C1，然后扫描数据集来判断这些只有一个元素的项集是否满足最小支持度的要求。那么满足最小支持度要求的项集构成集合 L1。然后 L1 中的元素相互组合成 C2，C2 再进一步过滤变成 L2，然后以此类推，知道 CN 的长度为 0 时结束，即可找出所有频繁项集的支持度。） Args: dataSet 原始数据集 minSupport 支持度的阈值 Returns: L 频繁项集的全集 supportData 所有元素和支持度的全集 """ # C1 即对 dataSet 进行去重，排序，放入 list 中，然后转换所有的元素为 frozenset C1 = createC1(dataSet) # 对每一行进行 set 转换，然后存放到集合中 D = map(set, dataSet) print 'D=', D # 计算候选数据集 C1 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 L1, supportData = scanD(D, C1, minSupport) # print "L1=", L1, "\n", "outcome: ", supportData # L 加了一层 list, L 一共 2 层 list L = [L1] k = 2 # 判断 L 的第 k-2 项的数据长度是否 &gt; 0。第一次执行时 L 为 [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]]。L[k-2]=L[0]=[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])]，最后面 k += 1 while (len(L[k-2]) &gt; 0): print 'k=', k, L, L[k-2] Ck = aprioriGen(L[k-2], k) # 例如: 以 &#123;0&#125;,&#123;1&#125;,&#123;2&#125; 为输入且 k = 2 则输出 &#123;0,1&#125;, &#123;0,2&#125;, &#123;1,2&#125;. 以 &#123;0,1&#125;,&#123;0,2&#125;,&#123;1,2&#125; 为输入且 k = 3 则输出 &#123;0,1,2&#125; print 'Ck', Ck Lk, supK = scanD(D, Ck, minSupport) # 计算候选数据集 CK 在数据集 D 中的支持度，并返回支持度大于 minSupport 的数据 # 保存所有候选项集的支持度，如果字典没有，就追加元素，如果有，就更新元素 supportData.update(supK) if len(Lk) == 0: break # Lk 表示满足频繁子项的集合，L 元素在增加，例如: # l=[[set(1), set(2), set(3)]] # l=[[set(1), set(2), set(3)], [set(1, 2), set(2, 3)]] L.append(Lk) k += 1 # print 'k=', k, len(L[k-2]) return L, supportData 到这一步，我们就找出我们所需要的 频繁项集 和他们的 支持度 了，接下来再找出关联规则即可！ 完整代码地址: https://github.com/apachecn/MachineLearning/blob/master/src/py2.x/11.Apriori/apriori.py 从频繁项集中挖掘关联规则前面我们介绍了用于发现 频繁项集 的 Apriori 算法，现在要解决的问题是如何找出 关联规则。 要找到 关联规则，我们首先从一个 频繁项集 开始。我们知道集合中的元素是不重复的，但我们想知道基于这些元素能否获得其它内容。某个元素或某个元素集合可能会推导出另一个元素。从先前 杂货店 的例子可以得到，如果有一个频繁项集 {豆奶,莴苣}，那么就可能有一条关联规则 “豆奶 -&gt; 莴苣”。这意味着如果有人买了豆奶，那么在统计上他会购买莴苣的概率比较大。但是，这一条件反过来并不总是成立。也就是说 “豆奶 -&gt; 莴苣” 统计上显著，那么 “莴苣 -&gt; 豆奶” 也不一定成立。 前面我们给出了 频繁项集 的量化定义，即它满足最小支持度要求。对于 关联规则，我们也有类似的量化方法，这种量化指标称之为 置信度。一条规则 A -&gt; B 的置信度定义为 support(A | B) / support(A)。（注意: 在 python 中 | 表示集合的并操作，而数学书集合并的符号是 U）。A | B 是指所有出现在集合 A 或者集合 B 中的元素。由于我们先前已经计算出所有 频繁项集 的支持度了，现在我们要做的只不过是提取这些数据做一次除法运算即可。 一个频繁项集可以产生多少条关联规则呢？如下图所示，给出的是项集 {0,1,2,3} 产生的所有关联规则:与我们前面的 频繁项集 生成一样，我们可以为每个频繁项集产生许多关联规则。如果能减少规则的数目来确保问题的可解析，那么计算起来就会好很多。通过观察，我们可以知道，如果某条规则并不满足 最小置信度 要求，那么该规则的所有子集也不会满足 最小置信度 的要求。如上图所示，假设 123 -&gt; 3 并不满足最小置信度要求，那么就知道任何左部为 {0,1,2} 子集的规则也不会满足 最小置信度 的要求。即 12 -&gt; 03 , 02 -&gt; 13 , 01 -&gt; 23 , 2 -&gt; 013, 1 -&gt; 023, 0 -&gt; 123 都不满足 最小置信度 要求。 可以利用关联规则的上述性质属性来减少需要测试的规则数目，跟先前 Apriori 算法的套路一样。以下是一些辅助函数: 计算置信度1234567891011121314151617181920212223242526# 计算置信度（confidence）def calcConf(freqSet, H, supportData, brl, minConf=0.7): """calcConf（对两个元素的频繁项，计算置信度，例如： &#123;1,2&#125;/&#123;1&#125; 或者 &#123;1,2&#125;/&#123;2&#125; 看是否满足条件） Args: freqSet 频繁项集中的元素，例如: frozenset([1, 3]) H 频繁项集中的元素的集合，例如: [frozenset([1]), frozenset([3])] supportData 所有元素的支持度的字典 brl 关联规则列表的空数组 minConf 最小置信度 Returns: prunedH 记录 置信度大于阈值的集合 """ # 记录置信度大于最小置信度（minConf）的集合 prunedH = [] for conseq in H: # 假设 freqSet = frozenset([1, 3]), H = [frozenset([1]), frozenset([3])]，那么现在需要求出 frozenset([1]) -&gt; frozenset([3]) 的置信度和 frozenset([3]) -&gt; frozenset([1]) 的置信度 # print 'confData=', freqSet, H, conseq, freqSet-conseq conf = supportData[freqSet]/supportData[freqSet-conseq] # 支持度定义: a -&gt; b = support(a | b) / support(a). 假设 freqSet = frozenset([1, 3]), conseq = [frozenset([1])]，那么 frozenset([1]) 至 frozenset([3]) 的置信度为 = support(a | b) / support(a) = supportData[freqSet]/supportData[freqSet-conseq] = supportData[frozenset([1, 3])] / supportData[frozenset([1])] if conf &gt;= minConf: # 只要买了 freqSet-conseq 集合，一定会买 conseq 集合（freqSet-conseq 集合和 conseq 集合是全集） print freqSet-conseq, '--&gt;', conseq, 'conf:', conf brl.append((freqSet-conseq, conseq, conf)) prunedH.append(conseq) return prunedH 递归计算频繁项集的规则1234567891011121314151617181920212223242526272829303132# 递归计算频繁项集的规则def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): """rulesFromConseq Args: freqSet 频繁项集中的元素，例如: frozenset([2, 3, 5]) H 频繁项集中的元素的集合，例如: [frozenset([2]), frozenset([3]), frozenset([5])] supportData 所有元素的支持度的字典 brl 关联规则列表的数组 minConf 最小置信度 """ # H[0] 是 freqSet 的元素组合的第一个元素，并且 H 中所有元素的长度都一样，长度由 aprioriGen(H, m+1) 这里的 m + 1 来控制 # 该函数递归时，H[0] 的长度从 1 开始增长 1 2 3 ... # 假设 freqSet = frozenset([2, 3, 5]), H = [frozenset([2]), frozenset([3]), frozenset([5])] # 那么 m = len(H[0]) 的递归的值依次为 1 2 # 在 m = 2 时, 跳出该递归。假设再递归一次，那么 H[0] = frozenset([2, 3, 5])，freqSet = frozenset([2, 3, 5]) ，没必要再计算 freqSet 与 H[0] 的关联规则了。 m = len(H[0]) if (len(freqSet) &gt; (m + 1)): print 'freqSet******************', len(freqSet), m + 1, freqSet, H, H[0] # 生成 m+1 个长度的所有可能的 H 中的组合，假设 H = [frozenset([2]), frozenset([3]), frozenset([5])] # 第一次递归调用时生成 [frozenset([2, 3]), frozenset([2, 5]), frozenset([3, 5])] # 第二次 。。。没有第二次，递归条件判断时已经退出了 Hmp1 = aprioriGen(H, m+1) # 返回置信度大于最小置信度的集合 Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) print 'Hmp1=', Hmp1 print 'len(Hmp1)=', len(Hmp1), 'len(freqSet)=', len(freqSet) # 计算置信度后，还有数据大于最小置信度的话，那么继续递归调用，否则跳出递归 if (len(Hmp1) &gt; 1): print '----------------------', Hmp1 # print len(freqSet), len(Hmp1[0]) + 1 rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 生成关联规则12345678910111213141516171819202122232425# 生成关联规则def generateRules(L, supportData, minConf=0.7): """generateRules Args: L 频繁项集列表 supportData 频繁项集支持度的字典 minConf 最小置信度 Returns: bigRuleList 置信度规则列表（关于 (A-&gt;B+置信度) 3个字段的组合） """ bigRuleList = [] # 假设 L = [[frozenset([1]), frozenset([3]), frozenset([2]), frozenset([5])], [frozenset([1, 3]), frozenset([2, 5]), frozenset([2, 3]), frozenset([3, 5])], [frozenset([2, 3, 5])]] for i in range(1, len(L)): # 获取频繁项集中每个组合的所有元素 for freqSet in L[i]: # 假设：freqSet= frozenset([1, 3]), H1=[frozenset([1]), frozenset([3])] # 组合总的元素并遍历子元素，并转化为 frozenset 集合，再存放到 list 列表中 H1 = [frozenset([item]) for item in freqSet] # 2 个的组合，走 else, 2 个以上的组合，走 if if (i &gt; 1): rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) else: calcConf(freqSet, H1, supportData, bigRuleList, minConf) return bigRuleList 到这里为止，通过调用 generateRules 函数即可得出我们所需的 关联规则。 分级法： 频繁项集-&gt;关联规则 1.首先从一个频繁项集开始，接着创建一个规则列表，其中规则右部分只包含一个元素，然后对这个规则进行测试。 2.接下来合并所有剩余规则来创建一个新的规则列表，其中规则右部包含两个元素。 如下图： 最后： 每次增加频繁项集的大小，Apriori 算法都会重新扫描整个数据集，是否有优化空间呢？ 信息来源于 ApacheCN GitHub地址: https://github.com/apachecn/MachineLearning]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>关联规则算法</tag>
        <tag>apriori</tag>
        <tag>毕业设计</tag>
        <tag>graduation</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记[二]]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括函数默认参数Parameter、对象代理Proxy、解构赋值以及多行字符串/模版变量 默认参数 (parameter)通过es6很方便地给函数设置一个默认参数1234567891011121314151617181920212223242526272829/** * es5中函数默认参数 * 如果需要这个函数的参数可填可不填，不填的话就给一个默认值 * 那么在函数体内要写一个判断或者采用或表达式（||） */function fn(a,b,c)&#123; if(b == null)&#123; b = 2 &#125; c = c || 3 return a+b+c&#125;fn(1) // 6fn(1,3) // 7fn(1,3,4) // 8/** * es6中函数默认参数 */function fn(a,b = 2,c = 3)&#123; return a+b+c&#125;//该函数使用babel编译过来的结果得到：// function fn(a) &#123;// var b = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;// var c = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 1;// return a+b+c;// &#125; 利用es6中的默认参数来进行对函数必选参数的检查:123456789101112131415function cheakParameter()&#123; throw new Error('can\'t be empty!')&#125;function fn(a=cheakParameter(),b=2,c=3)&#123; return a+b+c&#125;try&#123; fn()&#125;catch(e)&#123; console.log(e)&#125;finally&#123; &#125; es6中可变参数的写法1234567891011121314151617181920212223242526/** * es5中可变参数的写法 */function fn()&#123; var a = Array.prototype.slice.call(arguments) //arguments是一个伪数组，所以用数组的方式来写需要对数组的原型对象call()一下 var sum = 0 a.forEach(function(item)&#123; sum+=item*1 &#125;) return sum&#125;console.log(fn(1,2,3))/** * es6中可变参数的写法 */function fn(...a)&#123; // ... 是扩展运算符 ...a 就是可变参数 var sum = 0 a.forEach(item =&gt; &#123; sum += item*1 &#125;) return sum&#125;console.log(fn(1,2,3)) 对象代理 (Proxy) 如果有要求需要封装一份数据，这个数据只让内部的方法访问到，而外部的API无法访问高级程序语言(比如JAVA、C#等)有一个私有属性，就可以直接达到这样的效果在Javascript中，es3、es5只能通过模拟私有变量的方法达到这样的效果，但写法复杂而在es6中,它提供了一个对象代理(Proxy)的方法来解决私有变量的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * es3中采用构造函数来对数据进行保护 */var Person = function()&#123; var data = &#123; name: 'es3', age: 23, sex: 'male', &#125; this.get = function(key)&#123; return data[key] &#125; this.set = function(key,value)&#123; if(key !== 'sex')&#123; //这里就设置了sex值不可改，即达到了保护的效果 data[key] = value &#125; &#125;&#125;//声明一个实例var person = new Person()//读取console.table(&#123;name:person.get('name'),age:person.get('age'),sex:person.get('sex')&#125;)//修改person.set('name','es3-cname') // 修改成功person.set('sex','female') // 不会报错，但不会被执行成功/** * es5中采用defineProperty来对数据进行保护 */var person = &#123; name: 'es5', age: 25&#125;Object.defineProperty(person,'sex',&#123; writable: false, value: 'male'&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125;/** * es6中采用对象代理来对数据进行保护 */let Person = &#123; name: 'es6', age: 26, sex: 'male'&#125;let person = new Proxy(Person,&#123; get(target,key)&#123; return target[key] &#125;, set(target,key,value)&#123; if(key !== 'sex')&#123; //和es3中很相似，也是声明两个方法来获取和改变数据的值 target[key] = value &#125; &#125;&#125;)// 读取console.table(&#123;name:person.name,age:person.age,sex:person.sex&#125;)// 修改try&#123; person.sex = 'female' // 报错&#125;catch(e)&#123; console.log(e)&#125; 解构赋值12345678910111213141516171819202122/** * es5中取得对象属性的值或者数组的值 */var obj = &#123;a:100,b:200,c:300&#125;var arr = ['xxx','yyy','zzz']var a = obj.avar b = obj.bvar x = arr[0]var y = arr[1]var z = arr[2]/** * es6中的解构赋值 */const obj = &#123;a:100,b:200,c:300&#125;const arr = ['xxx','yyy','zzz']const &#123;a,c&#125; = objconst [x,y,z] = arr 多行字符串/模板变量 (`$`)1234567891011121314151617181920212223242526/** * es5中的多行字符串/模板变量 */var name = 'zhangsan'var age = 20var html = ''html += '&lt;div&gt;'html += ' &lt;p&gt;' + name + '&lt;/p&gt;'html += ' &lt;p&gt;' + age + '&lt;/p&gt;'html =+ '&lt;/div&gt;'/** * es6中的多行字符串/模板变量 */const name = 'zhangsan'const age = 20const html = ` &lt;div&gt; &lt;p&gt;$&#123;name&#125;&lt;/p&gt; &lt;p&gt;$&#123;age&#125;&lt;/p&gt; &lt;/div&gt;`//使用反引号能写多行字符串，还可以用$符号进行引入变量]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>parameter</tag>
        <tag>proxy</tag>
        <tag>解构赋值</tag>
        <tag>模版字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记[一]]]></title>
    <url>%2F2018%2F01%2F06%2FES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:es6的学习笔记，包括变量定义关键字let&amp;const、块级作用域Scope、箭头函数Arrow Function、类Class以及异步解决方案Promise 变量定义关键字 (let &amp; const)es5中定义常量 JS中全局对象是window，对于常量来说就可以将它绑定到window上 所用到的就是Object的defineProperty方法，它的第三个参数是一个描述符 123456789/** * es5中定义一个常量的写法 */Object.defineProperty(window,"a",&#123; value: 100, writable: false,&#125;)a = 200 //不会报错，但是没有执行成功console.log(a) //100 es6中定义常量1234567891011/** * es6中定义一个常量的写法 * 直接使用const修饰符 */let b = 100b = 200 //正确console.log(b) // 200const c = 100c = 200 //报错console.log(c) // 100 块级作用域 (Scope)解决es5中for循环使用var来声明i时候的变量提升问题12345678910111213141516171819202122232425262728293031/** * es5中for循环使用var关键字来声明i */var array = []for(var i=0;i&lt;3;i++)&#123; //这里有一个变量提升的问题 array[i] = function()&#123; //这里的i分别为 1、2、3 return i*2 //而这里返回的是一个函数表达式，此时是对i这个对象的引用，而不是对i的值的引用，所以i不会取到值，直到执行的时候i才能取到值。这个地方也是一个闭包。 &#125;&#125;console.table([ //此时函数表达式被执行，取到了i的值，但i已经变成了3 array[0](), array[1](), array[2]()])/** * es6中for循环使用let关键字来声明i */var array = []for(let i=0;i&lt;3;i++)&#123; array[i] = function()&#123; //使用let会有一个块级作用域，把当前i的值存下来使用 return i*2 //循环到下一步的时候会生成一个新的作用域，这样就不会出现变量提升的问题 &#125;&#125;console.table([ array[0](), array[1](), array[2]()]) es6中有块级作用域 由于es5中没有块级作用域，所以需要使用立即执行函数来指定（隔离）一个块作用域而在es6中只需要使用一对大括号就能直接指定一个块作用域 1234567891011121314151617181920212223242526272829303132/** * es5无块级作用域 * 在for循环外面还是可以取到item的值 */var obj = &#123;a:100,b:200&#125;for(var item in obj)&#123; console.log(item)&#125;console.log(item) // b (这里也有一个变量提升的问题)/** * 由于es5中没有块级作用域 * 所以为了程序的可读性，es5中推荐这么写 */var obj = &#123;a:100,b:200&#125;var itemfor(item in obj)&#123; console.log(item)&#125;console.log(item) // b/** * es6中有块级作用域 * 在for循环外面取不到item的值 */const obj = &#123;a:100,b:200&#125;for(let item in obj)&#123; console.log(item)&#125;console.log(item) // 报错: item is not defined 箭头函数 (Arrow Function)箭头函数语法形式123() =&gt; &#123;&#125; 小括号里面接收参数,若参数只有一个那么可以省略小括号大括号里面是函数体，若函数体只有一行那么可以省略大括号 map()方法中的箭头函数12345678910111213141516171819/** * es5中function函数 */var arr = [1,2,3]arr.map(function(item)&#123; return item+1&#125;)/** * es6中的箭头函数 */const arr = [1,2,3]arr.map(item =&gt; item + 1) //只传入一个参数，且函数体只有一行arr.map((item,index) =&gt; &#123; //传入多个参数，且函数体有多行 console.log(index) return item + 1&#125;) call()方法改变this的指向1234567891011121314151617181920212223242526/** * es5中使用call()方法来改变function函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(function(item)&#123; console.log('此时的this:',this) // 此时的this: Window &#125;)&#125;fn.call(&#123;a:100&#125;)/** * es6中使用call()方法来改变箭头函数中this的指向 */function fn()&#123; console.log('真正的this:',this) // 真正的this: &#123;a: 100&#125; var arr = [1] arr.map(item =&gt; &#123; console.log('此时的this:',this) // 此时的this: &#123;a: 100&#125; &#125;)&#125;fn.call(&#123;a:100&#125;) function函数与箭头函数中this的指向对比 在es5的function函数中，this的指向是函数被调用时的对象，也就是说该函数在被执行的时候，哪个对象调用了该函数，这个this指向的就是那个对象 在es6中的箭头函数中，箭头函数没有自己的this。箭头函数的this是继承而来，默认指向在定义该箭头函数时所处的对象(宿主对象) 12345678910111213141516171819202122232425262728293031323334/** * es5中的function函数中的this指向 */var Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: function()&#123; return this.a &#125; &#125;&#125;var foo = new Foo()console.log(foo.c.b()) // a+/** * es6中的箭头函数中的this指向 */let Foo = function()&#123; this.a = 'a' this.b = 'b' this.c = &#123; a: 'a+', b: ()=&gt;&#123; return this.a &#125; &#125;&#125;let foo = new Foo()console.log(foo.c.b()) // a 类 (class)构造函数123456789101112131415161718192021222324252627282930313233343536/** * es5中构造函数的写法 */function MathHandle (x,y)&#123; this.x = x this.y = y&#125;MathHandle.prototype.add = function() &#123; return this.x + this.y&#125;var m = new MathHandle(1,2)console.log(m.add())/* * es6中构造函数的写法 */class MathHandle&#123; constructor(x,y)&#123; this.x = x; this.y = y; &#125; add()&#123; return this.x + this.y; &#125;&#125; const m = new MathHandle(1,2);console.log(m.add()); // 3console.log(typeof MathHandle); // function//构造函数的显式原型的constructor属性值为构造函数本身console.log(MathHandle.prototype.constructor); // class MathHandle&#123;&#125; 类的继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * es5中继承的写法 *///动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125; // 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat()/** es6中继承的写法*/class Animal&#123; // 构造函数 constructor(name)&#123; this.name = name &#125; // 成员方法 eat()&#123; console.log(this.name + ' eat') &#125;&#125;// 继承class Dog extends Animal&#123; constructor(name)&#123; super(name) // 只要出现继承extends，就必须写super,而且需要把super放在constructor里面的第一行 this.name = name &#125; bark()&#123; console.log(this.name + ' bark') &#125;&#125;const dog = new Dog('hashiqi')dog.bark()dog.eat() 类的setter和setter ES6在类的内部可以使用get和set关键字来对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819202122232425/** * es6中的setter、getter */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; get getName()&#123; //这里的get形似方法，但它实际上是一个属性 return this.name &#125; set setName(value)&#123; this.name = value &#125;&#125;let par = new Parent()console.log('getter: ',par.getName)console.log('setter: ', par.setName = 'es6-cname')console.log(par.name,par.getName)//因为setter是一个属性，所以不能写成par.setName(es6-cname)//而是要写成赋值表达式的形式 类的静态方法和静态变量12345678910111213141516171819/** * es6中的静态方法和静态属性 */class Parent&#123; constructor(name = "es6")&#123; this.name = name &#125; static tell()&#123; //定义类的静态方法使用关键字static console.log('es6-static') &#125;&#125;Parent.type = 'es6-class' //静态属性没有关键字去声明//定义类的静态属性是在类定义完成后直接在类的外面进行赋值表达式定义Parent.tell() // 静态方法是通过类去调用，而不是通过类的实例去调用console.log(Parent.type) // 打印静态对象 异步 (Promise)Promise的介绍Promise是异步编程的一种解决方案，比传统的解决方案–回调函数和事件更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise。 所谓Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。 也之所以它是一个对象，所以它可以用来保存状态，从而解决了普通回调函数中的“回调地狱”以及“不能return”这两个问题。 三种状态:Promise对象的状态不受外界影响: pending: 进行中 fulfilled: 已经成功 rejected: 已经失败 状态改变:Promise对象的状态改变,只有两种可能: 从pending变为fulfilled 从pending变为rejected 这两种情况只要发生，状态就凝固了，不会再变了，这时就称为resolved（已定型） 使用Promise加载图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * es5中的回调函数 */function loadimg(src,callback,failed)&#123; var img = document.createElement('img') img.onload = function()&#123; callback(img) &#125; img.onerror = function()&#123; failed() &#125; img.src = src&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'loadimg(src,function(img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)/** * es6中的promise * 1.new Promise实例，而且要在后面return这个实例 * 2.new Promise时候要传入一个函数，该函数有resolve、reject两个参数 * 3.成功时候执行resolve()，失败时候执行reject() * 4.then()方法监听结果，并可以多次执行，达到分批处理的效果 */function loadimg(src)&#123; const promise = new Promise(function(resolve ,reject)&#123; const img = document.createElement('img') img.onload = function ()&#123; resolve(img) &#125; img.onerror = function()&#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = 'https://www.imooc.com/static/img/index/logo.png'var result = loadimg(src)//传两个函数作为参数，分别是成功和失败的回调result.then(function (img)&#123; console.log(img.width)&#125;,function()&#123; console.log('failed')&#125;)// 可以集成可以扩展可以分批处理,变得更加灵活result.then(function(img)&#123; console.log(img.height)&#125;) 多步调用:事件A–&gt;事件B–&gt;事件C123456789101112131415161718192021222324let ajax = function()&#123; console.log('start') return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-A') &#125;, 500); reslove() &#125;)&#125;ajax().then(function()&#123; //then()方法继续返回new Promise实例，就可以达到串联的效果 return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-B') &#125;, 1000); reslove() &#125;)&#125;).then(function()&#123; return new Promise(function(reslove,reject)&#123; setTimeout(function() &#123; console.log('case-C') &#125;, 1500); &#125;)&#125;) 异步过程中使用catch捕获错误1234567891011121314151617let ajax = function (num) &#123; return new Promise(function(reslove,reject)&#123; if(num&lt;4)&#123; reslove() &#125;else&#123; throw new Error('It Should under five!!!') &#125; &#125;)&#125;for (let i = 1;i &lt; 5;i++) &#123; ajax(i).then(function()&#123; console.log('i =',i) &#125;).catch(function(err)&#123; console.log('catch',err) &#125;)&#125; 异步加载图片的两个示例 所有图片都加载完之后再添加到页面 Promise.all()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中所有Promise实例的状态都发生改变，这个新的实例对象才会改变。 123456789101112131415161718192021222324252627//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(imgs)&#123; imgs.forEach(function(img)&#123; document.body.appendChild(img) &#125;)&#125;//高级用法Promise.all([ loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'), loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg')]).then(showImgs) 只要有一张图片加载完就添加到页面 Promise.race()表示把多个Promise实例当作一个新的Promise实例，可以传入一个数组作为参数，当数组中这多个Promise实例的状态只要有一个发生改变，这个新的实例对象就会改变。 123456789101112131415161718192021222324//加载图片的方法function loadImg (src) &#123; return new Promise((resolve,reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = function()&#123; resolve(img) &#125; img.onerror = function()&#123; reject(err) &#125; &#125;)&#125;//加载完之后将图片添加到页面上的方法function showImgs(img)&#123; document.body.appendChild(img)&#125;Promise.race([ loadImg('https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg'), loadImg('https://www.imooc.com/static/img/index/logo.png'), loadImg('https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png'),]).then(showImgs)]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>scope</tag>
        <tag>arrow function</tag>
        <tag>箭头函数</tag>
        <tag>class</tag>
        <tag>类</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建数据驱动的web界面的渐进式框架Vue]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84web%E7%95%8C%E9%9D%A2%E7%9A%84%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6Vue%2F</url>
    <content type="text"><![CDATA[Info: Vue官网内容深入了解 Vue起步实例方法/实例属性vm.$data.content可以访问vm实例data里的content内容。这个$表示的是Vue的实例方法或者实例属性。 全局组件1234//Vue中使用这样的语法来定义一个全局组件Vue.component("组件名",&#123;&#125;) 给某个元素标签加一个key值Vue在重新渲染页面时，它会尽量复用页面上的dom，但此时该dom上内容并不会被清空。要解决这个问题，可以给该元素标签加一个key值，此时Vue就能知道这是页面上一个唯一的元素，如果两个元素的key值不一样，Vue就不会复用以前的dom元素。这是Vue中虚拟DOM的diff算法中的内容。 Vue提供了7种数组的变异方法push() pop() shift() unshift() splice() sort() reverse() 给Vue组件绑定原生事件 原生事件是指绑定在子组件内部的template模板标签中的事件。 而绑定在父组件里面的子组件标签上的事件叫做自定义事件，它的触发可以通过父子组件间通信的方式。 自定义事件可以通过加一个native修饰符来变成原生事件。形如：`@click.native=”handleClick”`。 父子组件间通信 Vue中父组件向子组件传值是通过属性的形式，具体作法是在父组件里面的子组件标签类上绑定一个content属性作为需要传递的值，然后在子组件内部通过props参数来接受这个content值。 Vue中有一个叫”单向数据流”的概念。父组件可以给子组件任意传递参数，但是子组件只能使用这个参数而不能反过来去修改这个参数。原因是通过父组件:content=&quot;item&quot;这种形式向子组件传值，这个item其实是一个js表达式{}，里面的js对象等等都是引用类型。(如果是content=&quot;item&quot;这种形式，那么这个item是一个String字符串)如果其他子组件也用到了这个数据，那会就会造成混乱。解决这个问题的方法是在子组件内部使用data函数形式返回一个对象来存储这个传过来的数据再对其进行修改使用。 Vue中子组件向父组件传值是通过在子组件内部调用this.$emit()方法来向外触发一个事件以及传递一个参数，而在父组件模板中通过v-on(简写”@”)监听这个事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;todoList&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;id id="app"&gt; &lt;div&gt; &lt;input type="text" v-model="inputValue"&gt; &lt;button @click="handleBtnClick"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;todo-item v-for="(item,index) in list" :index="index" :content="item" @delete = "handleItemDelete"&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/id&gt; &lt;script&gt; var TodoItem = &#123; props:['content','index'], template: "&lt;li @click='handleBtnItem'&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;", methods: &#123; handleBtnItem: function(index)&#123; this.$emit("delete",this.index) &#125; &#125; &#125; var app = new Vue(&#123; el: '#app', components: &#123; TodoItem: TodoItem, &#125;, data: &#123; list: [], inputValue: '', &#125;, methods:&#123; handleBtnClick:function()&#123; if(this.inputValue != "")&#123; this.list.push(this.inputValue) this.inputValue = '' &#125; &#125;, handleItemDelete:function(index)&#123; this.list.splice(index,1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue基础Vue实例生命周期函数Vue生命周期简介 生命周期函数就是Vue实例在某一个时间点会自动执行的函数这些生命周期函数直接定义在Vue实例中而不放在methods对象中。 除了图片中的这8个生命周期函数，Vue还有另外三个生命周期函数，分别是deactivated()、activated()以及errorCaptured() Vue生命周期探究123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue实例生命周期函数&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;生命周期函数就是Vue实例在某一个时间点会自动执行的函数&lt;/h2&gt; &lt;div id="root"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', data: &#123; msg: 'hello Vue!' &#125;, beforeCreate: function () &#123; console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red" , "el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //undefined console.log("%c%s", "color:red","message: " + this.message) &#125;, created: function () &#123; console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //undefined console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeMount: function () &#123; console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red","el : " + (this.$el)); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, mounted: function () &#123; console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); //已被初始化 console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); //已被初始化 console.log("%c%s", "color:red","message: " + this.message); //已被初始化 &#125;, beforeUpdate: function () &#123; console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, updated: function () &#123; console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, beforeDestroy: function () &#123; console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); &#125;, destroyed: function () &#123; console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue生命周期总结 beforecreate: 举个栗子：可以在这加个loading事件 created: 在这结束loading，还做一些初始化，实现函数自执行 mounted: 在这发起后端请求，拿回数据，配合路由钩子做一些事情 beforeDestroy: 你确认删除XX吗 destroyed: 当前组件已被删除，清空相关内容 errorCaptured: 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。(err: Error, vm: Component, info: string) =&gt; ?boolean Vue的模板语法123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue模板语法&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div&gt;&#123;&#123;greetting&#125;&#125;&lt;/div&gt; &lt;div v-text="greetting"&gt;&lt;/div&gt; &lt;div v-html="greetting"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; greetting: '&lt;h1&gt;hello Vue!&lt;/h1&gt;' &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模指令v-text=””、v-html=””，双引号内指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for是例外情况)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 计算属性、方法、侦听器计算属性1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23 &#125;, //计算属性 computed: &#123; fullName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed计算属性有一个缓存机制，也就是只要计算属性所依赖的值没有发生改变时，就不会重新计算。这样就可以使性能得到优化。 方法1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName()&#125;&#125; &lt;!--此处因为fullName()是一个方法，所以要加上()来进行调用--&gt; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23 &#125;, //方法 methods: &#123; fullName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 只要页面数据发生改变，methods方法都会执行。所以同样的情况下优先选用computed计算属性。 侦听器123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性、方法、侦听器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &#123;&#123;age&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', age: 23, fullName: 'chris su' &#125;, //侦听器 watch: &#123; //监听firstName的变化 firstName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125;, //监听lastName的变化 lastName: function()&#123; console.log('计算了一次'); return this.firstName + ' ' + this.lastName &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 只要监听的值不发生变化，watch侦听器就不会被执行。 Vue计算属性中的getter和setter123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue计算属性的setter和getter&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &#123;&#123;fullName&#125;&#125; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; firstName: 'chris', lastName: 'su', &#125;, computed: &#123; //fullName写成对象的形式 fullName: &#123; get: function()&#123; return this.firstName + ' ' + this.lastName &#125;, set: function(value)&#123; var arr = value.split(" "); this.firstName = arr[0]; this.lastName = arr[1]; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的样式绑定通过class进行绑定class的对象绑定 将div节点绑定一个activated类，这个类显示与否取决于一个叫isActivated对象的值，初始值为false，即不显示这个类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .activated&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click='handleClick' :class="&#123;activated:isActivated&#125;" &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; isActivated: false &#125;, methods: &#123; handleClick: function()&#123; this.isActivated = !this.isActivated &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; class的数组绑定 将div节点绑定一个数组，数组中的每个变量的值都可以添加到这个节点的class类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .activated&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click='handleClick' :class="[activated]" &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; activated: "" &#125;, methods: &#123; handleClick: function()&#123; this.activated = this.activated === "activated" ? "" : "activated" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过style进行绑定style的对象绑定 将div节点绑定一个内联的style样式，这个样式的值由一个叫styleObj的值来决定 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div :style="styleObj" @click='handleClick' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; styleObj: &#123; color: "black" &#125; &#125;, methods: &#123; handleClick: function()&#123; this.styleObj.color = this.styleObj.color==="black" ? "red" : "black" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; style的数组绑定 将div节点绑定一个内联的style样式，这个样式的值由一个叫styleObj的数组来决定，数组中每个对象的值都可以添加到样式的值里 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的样式绑定&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div :style="styleObj" @click='handleClick' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; styleObj: &#123; color: "black" &#125; &#125;, methods: &#123; handleClick: function()&#123; this.styleObj.color = this.styleObj.color==="black" ? "red" : "black" &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的条件渲染v-if与v-show v-if=”false”是将该标签所对应的dom节点从页面上移除掉，而v-show=”false”是指该标签所对应的dom节点依然存在，只是加了个标签style=”display:none”。所以同样控制dom元素显示与否的场景下，更推荐v-show指令，这样使得页面性能更好。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的条件渲染&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-if="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div v-show="show"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, msg: 'hello Vue' &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-else-if与v-else v-else只能与v-if成对出现，且必须要连在一起使用，否则Vue会报错。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的条件渲染&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-if="show === 'a'"&gt;this is a&lt;/div&gt; &lt;div v-else-if="show === 'b'"&gt;this is b&lt;/div&gt; &lt;div v-else&gt;this is others&lt;/div&gt; &lt;button @click="handleClickB"&gt;change to b&lt;/button&gt; &lt;button @click="handleClickOthers"&gt;change to others&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: 'a', &#125;, methods: &#123; handleClickB: function()&#123; this.show = 'b' &#125;, handleClickOthers: function()&#123; this.show = 'others' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的set方法12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的set方法&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div v-for="(item,key,index) of userInfo"&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;key&#125;&#125; : &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; userInfo: &#123; name: 'su', age: 23, gender: 'male', &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在使用v-for遍历一个数组时，如果想要往userInfo中添加一项数据，不能通过userInfo[3]=””这种下标的形式来进行赋值，因为这样的话数据虽然得到了更改，但是页面并不会发生响应式的变化。在Vue中想要改变数组，要通过数组的几种变异方法，或者给这个对象一个新的引用，除了这两种方法，Vue还提供了一个叫做set的方法向对象中注入数据或者更改数据。 123Vue.set(vm.userInfo,"address","hangzhou") // Vue全局set方法给数组增加数据vm.$set(vm.userInfo,"address","hangzhou") // vm实例set方法给数组增加数据 123Vue.set(vm.userInfo,"age", 24) // Vue全局set方法改变数组中的数据vm.$set(vm.userInfo,"age", 24) // vm实例set方法改变数组中的数据 深入理解Vue组件使用Vue组件的几个细节点is标签 根据h5规范，&lt;tbody&gt;标签内部只能写&lt;tr&gt;标签，所以不能在&lt;tbody&gt;标签里直接写Vue组件。而是通过is属性来实现正确的效果。同理，&lt;ul&gt;、&lt;ol&gt;标签内部只能写&lt;li&gt;标签，&lt;select&gt;标签内部只能写&lt;option&gt;标签，都可以通过is属性来解决模板标签渲染时出现bug的情况。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;is标签&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;table&gt; &lt;tbody&gt; &lt;!-- 错误写法 --&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;row&gt;&lt;/row&gt; &lt;!-- 推荐写法(使用is标签) --&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;tr is="row"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; Vue.component('row',&#123; template:'&lt;tr&gt;&lt;td&gt;this is a row&lt;/td&gt;&lt;/tr&gt;' &#125;) var vm = new Vue(&#123; el: '#root' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 非根组件中的data里只能定义为函数 原因是根组件只会被调用一次，而非根组件（子组件）可能会被调用很多次。一个子组件在不同的地方调用时，里面的data可能会产生冲突。通过函数来返回一个对象的目的就是让每一个子组件都拥有一个独立的数据存储。 12345678Vue.component('row',&#123; data: function()&#123; return &#123; content: 'this is a row' &#125; &#125;, template: '&lt;tr&gt;&lt;td&gt;&#123;&#123; content &#125;&#125;&lt;/td&gt;&lt;/tr&gt;'&#125;) $refs在html标签内使用ref 在html标签内使用ref，得到的是该标签对应的dom节点。vue就可以通过这种方式来操作dom节点。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$ref&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;div @click="handleClick" ref = 'hello' &gt; hello Vue &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function()&#123; alert(this.$refs.hello.innerHTML) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue组件内使用ref 在Vue组件内使用ref，得到的是该组件数据的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;累加器&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;counter ref="num1" @change="add"&gt;&lt;/counter&gt; &lt;counter ref="num2" @change="add"&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;total&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.component('counter',&#123; template:'&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', data: function()&#123; return &#123; number: 0 &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number ++, this.$emit('change') &#125; &#125; &#125;) var vm = new Vue(&#123; el: "#app", data: &#123; total: 0, &#125;, methods: &#123; add: function()&#123; this.total = this.$refs.num1.number + this.$refs.num2.number; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件参数校验与非props特性组件参数校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * &lt;div id="root"&gt; * &lt;child :content="&#123;&#125;"&gt;&lt;/child&gt; // 带冒号则""里面是一个js表达式 * &lt;/div&gt; */// 传递的参数只能是StringVue.component('child',&#123; props: &#123; content: String &#125;&#125;)// 传递的参数可以是字符串也可以是数字类型Vue.component('child',&#123; props: &#123; content: [Number, String] &#125;&#125;)// 传递的参数只能是String，而且必须要传Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: true &#125; &#125;&#125;)// 传递的参数只能是String，而且可传可不传，如果不传那么给它一个默认值Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: false, default: 'default value' &#125; &#125;&#125;)// 传递的参数只能是String，而且必须要传，并且该字符串的长度必须大于5Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: true, // 自定义校验器 (参数value为一个形参，代表传递的参数)) validator: function(value) &#123; return (value.length &gt; 5) &#125; &#125; &#125;&#125;) 非props特性 子组件内部并没有通过props参数来接收在父组件里面的子组件模板中绑定的属性被称为非props属性。 非props特性不能在子组件内部通过插值表达式的形式来使用。 非props特性会被作为一个class类渲染到页面的dom元素中。 Vue中的插槽slot单个插槽除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。 (这点很类似于input里面的placeholder占位属性) 最初在 &lt;slot&gt;标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 12345678910111213141516&lt;!-- my-component 子组件有如下模板： --&gt;&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt;&lt;!-- 父组件的模板 --&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 123456789&lt;!-- 渲染结果 --&gt;&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名插槽使用场景：设计组合使用的组件时，内容分发 API 是非常有用的机制。 &lt;slot&gt;元素可以用一个特殊的特性 name 来进一步配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。 12345678910111213141516171819202122&lt;!-- app-layout子组件模板 --&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;!-- 父组件模板 --&gt;&lt;app-layout&gt; &lt;h1 slot="header"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot="footer"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 12345678910111213&lt;!-- 渲染结果 --&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 单个插槽和具名插槽示例1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的插槽slot&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;h1&gt;Vue&lt;/h1&gt; &lt;div class="footer" slot="footer"&gt;footer&lt;/div&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child',&#123; template: `&lt;div&gt; &lt;slot name="header"&gt;I'm a slot header&lt;/slot&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div&gt;Body&lt;/div&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 作用域插槽使用场景：当子组件作循环或者某一部分，它的dom结构不是本身自己定义，而是由父组件来传递一个展示的模板。 作用域插槽必须使用&lt;template&gt;标签进行包裹，同时这个插槽使用slot-scope=&quot;props&quot;来声明父组件接收到的子组件数据都存放在哪。&lt;template&gt;标签内部就是子组件模板的信息，来指明子组件展示(渲染)的方式。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中的作用域插槽&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;!-- 想要接收子组件传递过来的数据，需要使用template标签进行包裹并使用slot-scope属性来声明接收的数据存放在哪 --&gt; &lt;h1&gt;&#123;&#123;props.item&#125;&#125;&lt;/h1&gt; &lt;!-- 使用子组件传递过来的数据 --&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child',&#123; data:function ()&#123; return &#123; list: [1,2,3,4,5] &#125; &#125;, template: `&lt;div&gt; &lt;ul&gt; &lt;slot v-for="item of list" :item="item" // 子组件可以向父组件的插槽传递数据 &gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue动态组件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue动态组件&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;!-- 写法一:使用v-if来实现两个组件之间的切换显示 --&gt; &lt;child-one v-if="type === 'child-one'"&gt;&lt;/child-one&gt; &lt;child-two v-if="type === 'child-two'"&gt;&lt;/child-two&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;!-- 写法二:使用Vue自带的component标签来实现动态组件的效果 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;' &#125;) Vue.component('child-two',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods: &#123; handleClick: function()&#123; this.type = this.type === 'child-one' ? 'child-two' : 'child-one' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的动画特效Vue中css动画原理使用&lt;transition&gt;标签来实现一个显示隐藏的过渡动画效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;!-- &lt;link rel="stylesheet" href="./animate.css"&gt; --&gt; &lt;title&gt;vue中css动画原理&lt;/title&gt; &lt;style&gt; .fade-enter &#123; opacity: 0 &#125; .fade-enter-active &#123; transition: opacity 3s &#125; .fade-leave-to &#123; opacity: 0; &#125; .fade-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade"&gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中使用animate.css库 animate.css提供的动画类型其实是css3中@keyframe的动画效果。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./animate.css"&gt; &lt;title&gt;在Vue中使用animate.css库&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition enter-active-class = "animated tada" leave-active-class = "animated zoomOutLeft" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中同时使用过渡和动画使用appear类和appear-active-class类来给元素在第一次载入的时候也添加一个animated动画。 12345678&lt;transition appear enter-active-class = "animated tada" leave-active-class = "animated zoomOutLeft" appear-active-class = "animated swing"&gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt;&lt;/transition&gt; 在Vue中同时使用过渡和动画。在同时使用两种效果时它们的动画时间可能不一样，所以要再添加上type=&quot;transition&quot;这个属性来解决这个问题使得整体动画时间以transition为准。还可以使用:duration=&quot;{enter: 3000, leave: 5000}&quot;来自定义入场和出场的动画时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./animate.css"&gt; &lt;!-- 引入animate.css动画库 --&gt; &lt;title&gt;在Vue中同时使用过渡和动画&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: opacity 3s; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name = "fade" appear enter-active-class = "animated tada fade-enter-active" leave-active-class = "animated zoomOutLeft fade-leave-active" appear-active-class = "animated swing" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中的JS动画和Velocity.js动画库Vue中提供了很多js动画的钩子。@before-enter、@enter、@after-enter等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="./velocity.js"&gt;&lt;/script&gt; &lt;!-- 引入velocity.js动画库 --&gt; &lt;title&gt;Vue中的JS动画和Velocity.js动画库&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition name="fade" @before-enter="handleBeforeEnter" @enter="handleEnter" @after-enter="handleAfterEnter" &gt; &lt;div v-if="show"&gt;hello Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125;, handleBeforeEnter: function(el)&#123; el.style.opacity = 0 &#125;, handleEnter: function(el, done)&#123; //这个done为回调函数，执行这个函数After-enter才会执行 Velocity(el,&#123;opacity:1&#125;,&#123;duration: 1000, complete: done&#125;) &#125;, handleAfterEnter: function(el)&#123; alert('动画结束') &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中多个元素或组件的过渡使用v-if和v-else来写两个元素的toggle显示。&lt;transition&gt;标签内可以添加一个mode=&quot;in-out&quot;属性来确定元素显示隐藏的先后方式。由于Vue有一个会复用dom的机制，为了防止动画过渡不成功，要给元素标签上加一个key值。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;title&gt;Vue中多个元素的过渡&lt;/title&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0 &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="in-out"&gt; &lt;div v-if="show" key="hello"&gt;hello Vue&lt;/div&gt; &lt;div v-else key="bye"&gt;bye Vue&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true, &#125;, methods: &#123; handleClick: function()&#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue中多个组件的过渡动画。可以用v-if、v-else的方式，也可以用动态组件的方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Vue中多个组件的过渡&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0 &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt; &lt;transition mode="out-in"&gt; &lt;!-- 写法一:使用v-if来实现两个组件之间的切换显示 --&gt; &lt;child-one v-if="type === 'child-one'"&gt;&lt;/child-one&gt; &lt;child-two v-if="type === 'child-two'"&gt;&lt;/child-two&gt; &lt;/transition&gt; &lt;button @click="handleClick"&gt;toggle&lt;/button&gt; &lt;transition mode="in-out"&gt; &lt;!-- 写法二:使用Vue自带的component标签来实现动态组件的效果 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; Vue.component('child-one',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;' &#125;) Vue.component('child-two',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods: &#123; handleClick: function()&#123; this.type = this.type === 'child-one' ? 'child-two' : 'child-one' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>vue父子间通信</tag>
        <tag>vue生命周期函数</tag>
        <tag>vue模版语法</tag>
        <tag>vue样式绑定</tag>
        <tag>vue条件渲染</tag>
        <tag>vue动态组件</tag>
        <tag>vue组件原生事件</tag>
        <tag>组件</tag>
        <tag>is</tag>
        <tag>ref</tag>
        <tag>props</tag>
        <tag>slot</tag>
        <tag>animate</tag>
        <tag>velocity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Vue+Webpack打造todoApp应用]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%9F%BA%E4%BA%8EVue%2BWebpack%E6%89%93%E9%80%A0todoApp%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 此源码基于vue和webpack编写。前置知识有JavaScript、Css、Html、ES6、Stylus、Vue、Webpack、Webpack-cli、Bable等。 源码地址此Demo源码托管在本人Github，点击此链接直达。 使用步骤安装依赖 需要安装npm包管理工具 需要安装的npm依赖包详见pakage.json 开发环境 启动项目：npm run dev 浏览器调试：localhost:8000 生产环境 项目打包：npm run build 过程记录笔记前端的价值 搭建前端工程 网络优化（HTTP的理解） API定制 Node.js层 初始化一个项目 npm init 需要安装的依赖 npm install webpack -g(全局安装webpack)npm install webpack –save-dev(局部安装webpack，并且默认是安装最新版本)npm install css-loadernpm install vue-template-compilernpm install vuenpm install vue-loader vue中的render函数 render方法的实质就是生成template模板，通过调用一个方法来生成，而这个方法是通过render方法的参数传递给他的。 Vue中\$mount() Vue 的\$mount()为手动挂载，在项目中可用于延时挂载（例如在挂载之前要进行一些其他操作、判断等），之后要手动挂载上,new Vue时，el和$mount并没有本质上的区别。 “webpack –config webpack.config.js”配置的含义 “build”: “webpack –config webpack.config.js”以上配置的意义是强制终端在执行npm run build的时候调用的是本地安装的webpak，而不是全局的webpack，并且在执行npm run build命令的时候，会执行webpack.config.js文件 css-loader、style-loader说明 loader: ‘css-loader’，这个只是帮我们处理CSS文件。以下写法能帮我们把CSS样式插到HTML结构中: 1234use: [ 'style-loader', 'css-loader'] (在此之前需要安装依赖：npm install style-loader) webpack处理图片文件代码解析 代码： 123456789&#123; test: /\\.(gif|jpg|jpeg|svg)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 1024 , name: '[name]-aa.[ext]' &#125;&#125; 该代码的作用就是使用url-loader来处理后缀名为.gif、.jpg、.jpeg、.svg的文件，将其转化为base64代码，直接写在js文件里面，而不用生成一个新的文件。 使用对象的写法是为了配置url-loader的一些选项。limit:1024的含义就是当图片小于1024kb的时候，转化为base64代码，减少了HTTP请求。name配置的含义是定义输出文件的名字】(配置里面的name是原来图片的名字，ext是转化后的后缀名)可以使用下面两段代码来进行测试 12345678910111213141516body &#123; color: blue; background-image: url(../images/bg.jpg);&#125;//vue组件不能直接挂载到HTML文件中的解决方案import Vue from 'vue'import App from './app.vue'import './assets/styles/test.css'import './assets/images/bg.jpg'const root = document.createElement('div')document.body.appendChild(root)new Vue(&#123; // 将app.vue组件挂载到HTML文件中 render: (h) =&gt; h(App)&#125;).$mount(root) 使用命令：npm run build，将可以在dist目录下看到一张转化后的图片(bg-aa.jpg) webpack强大的地方之一就是能够处理任何的依赖文件，比如在CSS文件中定义的图片，webpack也会使用配置好的url-loader将其进行处理。 CSS预处理器(使用stylus)安装： npm install stylus stylus-loader 配置：1234&#123; test: /\.styl/, use: ['style-loader', 'css-loader', 'stylus-loader']&#125;, 使用npm安装依赖包的细节 1、npm install webapck –save-dev：表示安装的webpack只在开发环境(dev)中使用，项目发布之后就不会用到，简写方式为npm i webapck -D。2、npm install vue –save：表示安装的vue在开发环境和正式环境中都会被用到，简写方式为npm i vue -S webpack-dev-server的配置和使用 安装：npm i webpack-dev-server配置：”dev”: “webpack-dev-server –config webpack.config.js” 通过以上的配置，那么使用命令npm run dev也能够实现打包项目，并且它是开发模式打包项目 如何分辨是在开发环境还是正式环境 步骤一： npm i cross-env步骤二：为了能够在不同的平台都运行webpack.config.js文件，我们需要在package.json中这样来配置：“build”: “cross-env NODE_ENV=production webpack –config webpack.config.js”,“dev”: “cross-env NODE_ENV=development webpack-dev-server –config webpack.config.js”步骤三：配置webpack.config.js文件 如何让打包好的js文件自动包含到HTML文件中 步骤一：npm install html-webpack-plugin]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>es6</tag>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>npm</tag>
        <tag>stylus</tag>
        <tag>todo</tag>
        <tag>bable</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目中的数据可视化]]></title>
    <url>%2F2017%2F11%2F21%2F%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[近几年随着大数据逐渐火热，数据可视化也就显得格外重要。。 最近几年随着大数据的兴起，以及浏览器性能的提升，数据可视化成为了一个热点，前端也冒出来了很多数据可视化的岗位。本人也做过一些数据可视化相关的产品，下面聊聊对数据可视化的一些思考。本文的数据可视化一般专指互联网公司web前端接触的数据可视化。 数据可视化，是关于数据视觉表现形式的科学技术研究。其中，这种数据的视觉表现形式被定义为，一种以某种概要形式抽提出来的信息，包括相应信息单位的各种属性和变量。它是一个处于不断演变之中的概念，其边界在不断地扩大。主要指的是技术上较为高级的技术方法，而这些技术方法允许利用图形、图像处理、计算机视觉以及用户界面，通过表达、建模以及对立体、表面、属性以及动画的显示，对数据加以可视化解释。与立体建模之类的特殊技术方法相比，数据可视化所涵盖的技术方法要广泛得多. ———————-百度百科 而前端常说的视觉可视化大部分是指借助曲线图表等展示形式把一些相关数据更直接、形象、生动、具体的展示在web页面上。要做一个好的数据产品是需要 产品经理-&gt;设计师-&gt;前端-&gt;后端-&gt;用户整个链路紧密配合密切合作并且协调的。 产品需要懂数据可视化的理论基础，哪些数据可以可视化，哪些数据是用户最想要的。 设计师包括视觉和交互，需要理清楚数据怎么展示最合理，曲线，柱状图，饼状图，都有哪些优缺点，不能仅仅为了美观设计了一个好看的图形，而不顾实际数据情况，展示出来就很奇怪。 前端其实在里面是最紧密的一环，数据怎么获取，什么格式对前后端最友好，采用什么技术方案，是svg的库，还是canvas的库，是自己撸还是用现成的库。实现成本有多高，性能、扩展性怎么样都是需要考虑的问题 后端需要考虑的就是数据的拉取，需要考虑数据格式以及能获取哪些数据。 以上分工只是一个粗略的说明。这里看了一篇文章小心，这饼有毒！论饼图的正确打开方式里面讲的一些经历可能大家都遇到过，我也深有同感。 我的这些数据，好像柱状图、折线图、饼图都能表示啊，到底应该选哪个？ 饼图和环形图也差不多，取决于我要不要在中间显示其他内容吗？ 我可不可以将数据映射到饼图的半径维度上 数据可视化最重要的不是好看，而是让人一目了然的明白这个图表传达出来的意思。 其实这方面是有相关的信息图表学的相关知识储备的话就不会犯这些错误了。支付宝有个G2 里面有两个相关的图表学基础知识介绍，我个人认为这是G2 比echart更近一步，更规范化的点之一。 详见这里 可视化基础-图表使用建议 https://antv.alipay.com/vis/doc/chart/classify/compare.html 可视化基础-图表设计指引规范 https://antv.alipay.com/vis/doc/design/index.html 以及经典文献： 在数据可视化的研究和实现中，《数据可视化》、《The Grammarof Graphics》、《深入浅出统计学》、《计算机图形学几何工具算法详解》、《Visualization Analysis and Design》 、《ggplot2：数据分析与图形艺术》 。 叨叨了这么多基础，下面说说前端在可视化里的一些相关的发展和技术选型 首先需要明白一个观点：技术选型没有一劳永逸的，永远是根据你的项目实际情况以及你的个人偏好和技术基础来做的选择。 下面说说常见的一些图表库和相关技术： 1. echartsecharts算是国产的图表库里最好的了。EFE团队也是国内技术实力最雄厚的可视化团队.采用canvas作为渲染容器。底层一些实现比如鼠标事件啥的用的自己开发的zrender框架。 echart2.0对应不同的组件比如坐标轴图例是用不同的canvas来渲染的，echart3之后都合并到一个canvas里面了，猜测应该是底层的框架升级了 博客： http://efe.baidu.com/， 这个博客更的很慢了。 http://echarts.baidu.com/blog/posts/ 这个更得多点。 2.highcharts这个框架用的人也不少，主打就是IE6也支持。。。。。。。。。然并卵微软都不支持IE6了。淘宝连ie8都不支持了。。。。收费的库，底层用的SVG。私以为他的API使用起来没有Echart友好。 3.G2-支付宝蚂蚁金服的产品，图标容器为canvas，玉伯的团队开发的。怎么说呢。。这个东西看着还不错，不过实际使用的时候大部分人还是会不由自主的去选择前面两个，大阿里的开源东西就是这么个鬼情况。东西是不错，就怕搞着搞着团队没了。。 4.d3.jsd3也算是资历比较老的一个产品了，采用svg作为图标容器。刚开始出来的时候各种动画比较惊艳，图标类型也比较丰富，感觉echarts一开始也参照它的图表类型新增了好几个图表示例。 d3的优点是各种示例demo比较完善适合拿来就用，缺点就是demo不适合二次开发，熟悉api的话也可以直接自己画，他的api是对svg的dom的一种整理和兼容，类比于jquery对应html的dom。 其他： 一两年前阿里妈妈貌似出过一个图表库，我当初还给他们留言说：为啥不先出一个移动端的图表库说不定更有市场。貌似最后沦为KPI的牺牲品 以上就是最常见的一些图表库，那么我们需要根据实际项目需要来做一些技术选型。 移动端图表库，echarts和G2应该都可以。pc端就看个人喜好了。报表类型的项目看设计师画的效果稿吧，echarts可定制性最高，G2没用过，highcharts文档不健全。 监控类型的项目需要频繁更新数据的优选选择canvas的性能应该更好。 下面说说数据可视化的一般应用场景： 报表类 报表类使用场景最多，使用的图表也最简单一般echarts里面的示例图表就能满足了。 监控类 监控类稍微复杂点，一般涉及到实时性和稳健性，开发的时候需要考虑后端的接口性能，以及页面图表渲染的性能问题，数据量大了之后对前后端都很有挑战性。做起来也比较有意思，和业务场景结合起来能做一整套的数据可视化的产品系统。 动效PR稿类 这种类型的项目一般都有一个特点：急，炫，累。项目周期很急，动画效果要很炫，干起活来很累。偶尔做做还行，一直搞，就感觉路走的有点偏，而且一般很少能找到现成的库和框架，前期需要大量的技术调研和技术储备。相关的库一般需要canvas的效果库，webGL的库，比如:http://www.pixijs.com/ ，threejs，要求更高的可能需要一些游戏库来帮忙了比如：https://www.egret.com/ ，http://www.createjs.com/等等。 地图类 这类的数据可视化单独拿出来是因为现在越来越多的数据可视化场景里需要用到地图。这也是数据可视化最麻烦的一直，一般我们借助echart的地图，或者百度地图，高德地图等来开发，其实百度地图也出了个地图可视化的库 http://mapv.baidu.com/ ，展示效果没有echart好。。。。需要定制开发的同学其实可以直接拿百度地图之类的然后在地图上蒙一层覆盖类，然后在这个覆盖类里填充一个canvas做一些自己的扩展参见百度地图的demo；背后的地图。。可以用css隐藏掉。。。。。 数据可视化系统 这个范畴比较大，还是需要看业务场景，某些业务场景就特别适合做一堆相关联的数据可视化系统。做好了成就感还是满满的。 ================================================ 参考于：https://www.56way.com/p/102.html]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>前端</tag>
        <tag>数据可视化</tag>
        <tag>数据</tag>
        <tag>echarts</tag>
        <tag>highcharts</tag>
        <tag>G2</tag>
        <tag>d3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识]]></title>
    <url>%2F2017%2F09%2F21%2FVue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vue的三个特点： 易用 123&lt;div id='app'&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el:'#app', data:&#123; message:'hello vue!' &#125;&#125;) 灵活（渐进式） 无论是单页面程序还是多页面程序，我们首先都需要通过声明式渲染来渲染页面上的每一个字段；因为我们的界面需要去展现一些功能，展现一些信息，就需要渲染来实现； 把一些公共的头部和公共的尾部抽出来去做成一个组件； 做单页面程序用到路由,需要把vue-resource、vue-router等等插件拉进来去做一个路由的功能； 如果实现的业务足够复杂，需要用到大量的组件，而且难以管理这些组件的状态，此时就需要引进vuex，用来集中管理组件的状态； 整个项目做完之后，需要通过构建工具来build系统，提升效率，最后形成一个完整的项目。 高效 vue的min+gzip的运行大小：16kb； 超快虚拟DOM； 最省心的优化。 Vue组件的重要选项： data（数据源） methods（方法） watch（监听） Vue模版指令（html和vue对象的粘合剂）： 数据渲染：v-text 、v-html 、&#123;&#123; &#125;&#125; 控制模块隐藏：v-if 、v-show 渲染循环列表：v-for 事件绑定：v-bind 表单渲染：v-model: 用于文本框、下拉框、单选复选、textarea等等，具有一个双向绑定的特性。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记几道Codewars上面的编程题]]></title>
    <url>%2F2017%2F07%2F24%2F%E8%AE%B0%E5%87%A0%E9%81%93Codewars%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[每次做完看到别人的答案：wtf ??? NO.1题目描述： 解法:12345678function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); Math.min()方法: 可以得到数组中最小的数,Math.min.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 splice()方法: arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。 NO.2题目描述： 我的解法：123456function isTriangle(a,b,c)&#123; var p = (a + b + c)/2; var S = Math.sqrt(p*(p-a)*(p-b)*(p-c)); return S &gt; 0;&#125; 得票最高的解法： orz。。 NO.3题目描述： 我的解法：123456789101112function sumArray(array) &#123; if(!array || array == null)&#123;return 0&#125;; var max = Math.max.apply(null,array); var min = Math.min.apply(null,array); array.splice(array.indexOf(max),1); array.splice(array.indexOf(min),1); console.log(array); for(var sum = 0,i = 0;i &lt; array.length;i++)&#123; sum += array[i]; &#125; return sum;&#125; 得票最高的解法：1sumArray = a =&gt; a ? a.sort((x, y) =&gt; x - y).slice(1, -1).reduce((s, e) =&gt; s + e, 0) : 0 ??? (黑人问号脸。。 NO.4题目描述： 我的解法：1234567var gimme = function(inputArray) &#123; let min = inputArray.indexOf(Math.min(...inputArray)), max = inputArray.indexOf(Math.max(...inputArray)); if (min === 0 &amp;&amp; max === 2 || max === 0 &amp;&amp; min === 2) return 1; if (min === 1 &amp;&amp; max === 2 || max === 1 &amp;&amp; min === 2) return 0; if (min === 0 &amp;&amp; max === 1 || max === 0 &amp;&amp; min === 1) return 2;&#125;; 得票最高的解法： 溜了溜了。。 PS。虽然这些高票答案精简得不行，但至少我写的代码块可读性强啊。。（微笑]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>算法</tag>
        <tag>codewars</tag>
        <tag>coding</tag>
        <tag>编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【二】]]></title>
    <url>%2F2017%2F07%2F20%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO : 前端面试。 基础部分 1.prototype和proto的关系是什么2.meta viewport原理3.域名收敛是什么4.float和display：inline-block；的区别5.前端优化策略列举6.首屏、白屏时间如何计算7.闭包8.作用域链9.ajax如何实现、readyState五种状态的含义10.jsonp如何实现11.怎么处理跨域12.restful的method解释13.get和post的区别14.事件模型解释15.编写一个元素拖拽的插件16.编写一个contextmenu的插件17.编写web端cookie的设置和获取方法18.兼容ie６的水平垂直居中19.兼容ie的事件封装20.h5和原生android的优缺点21.编写h5需要注意什么22.xss和crsf的原理以及怎么预防23.css优先级24.如何实现点击radio的文字描述控制radio的状态（通过label实现）25.delegate如何实现 框架原理angularjs 1.angular的directive怎么写2.angular的脏检查（双向绑定）是如何实现的3.依赖注入如何实现4.scope如何实现5.$parse模块如何实现（主要自己写了一个类似的库） react 1.react在setState后发生了什么（直接说了setState源码）2.flux解释3.对react有什么了解（直接说了react中虚拟dom内部表示，mount过程源码和同步过程源码） jsBridge 如何说服对方使用jsBridge requirejs 1.amd和cmd区别，怎么了解到这些区别的，是否是去看了规范2.requirejs那些经常用的方法，然后对其进行解释 weex weex实现大致原理（只写过demo，面试管很好没有难为我，只问了这一个问题） http协议 1.accept是什么，怎么用2.http协议状态码，302和303的区别3.前端缓存如何实现、etag如何实现、etag和cache-control的max-age的优先级哪个比较高以及为什么、cache-control和expire优先级哪个比较高以及为什么 node 1.Buffer模块是干什么的2.Stream是什么，使用的两种模式3.http模块如何将异步处理方式实现成同步处理方式，具体解析请参考http模块如何将异步处理转成同步处理http://blog.csdn.net/wanglei20116527/article/details/62892070 其他问题 1.utf8和gbk的区别2.知道页面上某个点的坐标，如何获取该坐标上的所有元素3.angular、react和jQuery适合哪些应用场景（建议查看各个框架产生背景）4.7点15分小于180度的夹角是多少5.大数相加6.给５升和６升的水杯如何倒出３升的水7.一班喜欢足球的人60%，喜欢排球的70%，喜欢篮球的80%，求喜欢足球和排球的占多少8.前端异常监测如何实现9.直播点赞按钮的冒泡功能如何实现10.js的uglify如何实现11.项目架构、如何带人（自己带过一个小团队）12.前端工程化方面做了哪些东西 面试中的收获 最开始面试时只阅读过angular源码，一面完后面试官对我说react用的不熟悉没关系，弄懂原理也可以，之后三天疯狂阅读react源码，对于react中虚拟dom内在表示、mount过程、setState的同步过程有了清晰的认识。面试官建议去阅读node的http模块和Stream模块源码，其中node-v0.1.100的http模块源码已经阅读完，并且写了一个基于net模块的http模块。node-v6.9.1的Stream模块源码现在还在阅读中。初步了解了前端异常监测，并且了解了百姓网、腾讯和阿里在前端异常监测的一些方案和框架。阅读了大量前端工程化方面的博文，对前端工程化有了进一步的理解。了解了angular和react产生背景。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>html/css</tag>
        <tag>http</tag>
        <tag>frame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端面试【一】]]></title>
    <url>%2F2017%2F07%2F18%2FWeb%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[INFO ：这段时间遇到的面试题。 前端页面由哪三层构成及各层的作用 结构层：由 HTML 或 XHTML 之类的标记语言负责创建，仅负责语义的表达。解决了页面“内容是什么”的问题。 表示层：由CSS负责创建，解决了页面“如何显示内容”的问题。 行为层：由脚本语言负责。解决了页面上“内容应该如何对事件作出反应”的问题。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea; 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote; 空元素：br、meta、hr、link、input、img。 html5有哪些新特性、移除了那些元素？ 新特性： 语义化更好的内容元素，比如 article、footer、header、nav、section，表单控件，calendar、date、time、email、url、search; 一些功能标签，如绘画 canvas，用于媒介播放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除； 新的技术，如webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； meta标签 charset属性：单独使用，设置文档字符及编码格式。写法：\常见的中文编码格式： B-2312: 国标码，简体中文 GBK：扩展的国标编码，简体中文 UTF-8: 万国码 Unicode码，基本兼容各国语言 name属性：需配合content属性使用，主要用于给搜索引擎提供必要信息。写法：\&lt;meta name=”属性值” content=”属性值详细内容”重要属性值： author 作者，声明网站作者，常用公司网址表示 keywords 网站关键字，多个关键字，用英文逗号分隔 description 网页描述，搜索引擎显示在title下的描述内容 http-equiv属性: 也需要与content属性配合使用，前者是用于声明即将修改哪些属性值，而实际的属性值内容，在content中描述。而这个属性的用途是把 content 属性关联到 HTTP 头部。常用属性值： Content-Type HTML4.01之前的文档内容编码声明。 refresh 网页刷新 set-Cookie 设置浏览器cookie缓存 http-equiv 属性为名称/值对提供了名称。并指示服务器在发送实际的文档之前先在要传送给浏览器的 MIME 文档头部包含名称/值对。 当服务器向浏览器发送文档时，会先发送许多名称/值对。虽然有些服务器会发送许多这种名称/值对，但是所有服务器都至少要发送一个：content-type:text/html。这将告诉浏览器准备接受一个 HTML 文档。 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv="charset" content="iso-8859-1"&gt;&lt;meta http-equiv="expires" content="31 Dec 2008"&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 对标签语义化的理解 去掉或者丢失样式的时候能够让页面呈现出清晰的结构； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 meta标签优化 关键词分析 付费给搜索引擎 链接交换和链接广泛度（Link Popularity） 合理的标签使用 HTML与XHTML二者有什么区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 DOCTYPE作用是什么以及标准模式与兼容模式的区别 &lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写&lt;!DOCTYPE HTML&gt;HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 问：如果我不放入&lt;!DOCTYPE html&gt; ，HTML5还会工作么？答：不会，浏览器将不能识别他是HTML文档，同时HTML5的标签将不能正常工作。 iframe有哪些缺点 iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么以及它该如何使用 作用：label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 用法： 1234&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type=“text“name="Name" id="Name"/&gt;&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt; canvas和svg图形的区别是什么 简述盒模型 文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。CSS3中有个box-sizing属性可以控制盒子的计算方式: W3C盒子模型：content-box：padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和。 IE6盒子模型：border-box：padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值。 position的几个取值以及它们定位的原点 absolute：生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 （IE6不支持）。 relative：生成相对定位的元素，相对于其在普通流中的位置进行定位。 static：默认值。没有定位，元素出现在正常的流中忽略 top, bottom, left, right z-index 声明）。 inherit：规定从父元素继承 position 属性的值。 position的absolute与fixed的异同点 相同： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上 区别： absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 display的取值以及它们的作用 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。象行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 像块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 CSS3的Flexbox（弹性盒布局模型）以及适用场景 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做居中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 CSS中的文档流普通流就是正常的文档流，在HTML里面的写法就是从上到下，从左到右的排版布局。其中涉及到了块状元素和内联元素。脱离文档流的几个属性：绝对定位(absolute)、固定定位(fixed)、浮动(float)。 请列举几种可以清除浮动的方法 浮动会漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是这种特性，导致框内部由于不存在其他普通流元素了，表现出高度为0（高度塌陷）。 添加额外标签，例如\&lt;div style=”clear:both”/div&gt; 使用br标签和其自身的html属性，例如\ 父元素设置 overflow：hidden；在IE6中还需要触发hasLayout，例如zoom:1； 父元素设置 overflow：auto；同样IE6需要触发hasLayout； 父元素也设置浮动； 父元素设置display: table； 使用 :after 伪元素；由于IE6-7不支持 :after，使用 zoom: 1 触发hasLayout。 在CSS2.1里面有一个很重要的概念，那就是 Block formatting contexts （块级格式化上下文），简称BFC。 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，同时BFC仍然属于文档中的普通流。 IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念。 对BFC规范的理解 BFC全称是Block Formatting Context，即块格式化上下文。它是CSS2.1规范定义的，关于CSS渲染定位的一个概念。 BFC是页面CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 BFC的一个最重要的效果是，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 利用BFC可以闭合浮动、防止与浮动元素重叠、以及多栏布局的一种方式。 请列举几种隐藏元素的方法 visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。 opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。 display: none；元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。 HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态 height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。 filter: blur(0)；将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中。 CSS选择器以及可以继承的css属性 id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height CSS的权重规则 一个行内样式：+1000； 一个ID：+100； 属性选择器/class类/伪类选择器：+10； 一个元素名/伪对象选择器：+1。 CSS3新增伪类有那些 p:first-of-type 选择属于其父元素的首个 \ 元素的每个\元素。 p:last-of-type 选择属于其父元素的最后 \元素的每个\元素。 p:only-of-type 选择属于其父元素唯一的 \元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 \元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 \ 元素。 :checked 单选框或复选框被选中。 :disabled 控制表单控件的禁用状态。 CSS伪类与CSS伪对象的区别 CSS 引入伪类和伪元素的概念是为了描述一些现有CSS无法描述的东西，根本区别在于：它们是否创造了新的元素（抽象） 伪类：一开始用来表示一些元素的动态状态，随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪对象：代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 外边距重叠 外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 px和em的区别 px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。 浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 em和rem的区别 em是相对长度单位，相对于当前对象内文本的字体尺寸； em是CSS3新增的一个相对单位（root em，根em），这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 用纯CSS创建一个三角形的原理把上、左、右三条边框隐藏掉（颜色设为 transparent） 1234567div &#123; height: 0; width: 0; display: block; border: transparent solid 20px; border-left: #005AA0 solid 20px;&#125; li与li之间有看不见的空白间隔是什么原因引起的以及它的解决办法行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul &#123; list-style: none; /*解决空格问题*/ font-size: 0; &#125; li &#123; display: inline-block; height: 70px; width: 150px; line-height: 70px; text-align: center; border: #005AA0 solid 2px; /*解决空格问题*/ font-size: 16px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;li&gt;li标签&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 如何解决图片与文字的不对齐 vertical-align：最有效的一种方式； margin： 需要不断调试图片的高度，精确度难以保证； position：同样是需要不断调试图片的高度，精确度难以保证。 png、jpg、gif 这些图片格式解释一下，分别什么时候用，有没有了解过webp？ GIF是一种索引颜色格式，在颜色数很少的情况下，产生的文件极小。GIF格式支持背景透明；GIF格式支持动画；GIF格式支持图形渐进；GIF格式支持无损压缩。 JPG最主要的优点是能支持上百万种颜色，从而可以用来表现照片。此外，由于JPG图片使用更有效的有损压缩算法，从而使文件长度更小，下载时间更短。JPG较GIF更适合于照片，因为在照片中损失一些细节不像对艺术线条那么明显。另外，JPG对照片的压缩比例更大，而最后的质量也更好。 PNG 是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。png是一种无损耗的图像格式。 Webp格式：Google开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。当然其也是一种有损压缩，其主要目的就是加快网络图片的传输效率，让图片能更快的显示在用户的眼前。目前所知道的只有高版本的W3C浏览器才支持这种格式，比如chorme39+，safari7+等等。 什么是CSS 预处理器/后处理器 预处理器：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器：Postcss，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 什么是CSS Hack针对不同的浏览器写不同的CSS,就是 CSS Hack。IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如： 123456789101112131415 // 1、条件Hack&lt;!--[if IE]&gt; &lt;style&gt; .test&#123;color:red;&#125; &lt;/style&gt;&lt;![endif]--&gt;// 2、属性Hack .test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */ &#125;// 3、选择符Hack * html .test&#123;color:#090;&#125; /* For IE6 and earlier */ * + html .test&#123;color:#ff0;&#125; /* For IE7 */ 什么叫优雅降级和渐进增强及其区别 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给； 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要； 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 什么是JavaScript闭包 当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。闭包有如下特性： JavaScript允许你使用在当前函数以外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量 闭包可以更新外部变量的值 用闭包模拟私有方法 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。 在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ JS如何实现面向对象和继承机制 创建对象方法： 利用json创建对象 使用JavaScript中的Object类型 通过创建函数来生成对象 继承机制： 构造函数绑定，使用call或apply方法，将父对象的构造函数绑定在子对象上 prototype模式，继承new函数的模式 直接继承函数的prototype属性，对2的一种改进 利用空对象作为中介 在ECMAScript5中定义了一个新方法Object.create()，用于创建一个新方法 拷贝继承，把父对象的所有属性和方法，拷贝进子对象，实现继承。参考《JavaScript中的对象克隆》 对this指针的理解 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 this指的是：调用函数的那个对象。 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 作为对象方法的调用，这时this就指这个上级对象。 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 简述同步和异步JavaScript是单线程，一个时间段内，JavaScript只能干一件事情。任务队列分为同步任务和异步任务。 同步是阻塞模式：同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步是非阻塞模式：异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 JS常用的绑定事件的方法有哪些 在DOM元素中直接绑定，DOM元素，可以理解为HTML标签，onXXX=”JavaScript Code”，查看事件列表。 在JavaScript代码中绑定，elementObject.onXXX=function(){}，通称为DOM0事件系统。 绑定事件监听函数，标准浏览器使用 addEventListener() ，IE11以下版本attachEvent() 来绑定事件监听函数，通称为DOM2事件系统。 Event对象的常见应用 event.preventDefault()：阻止事件的默认行为 event.stopPropagation()：阻止事件的进一步传播，也就是阻止冒泡 event.stopImmediatePropagation()：阻止剩余的事件处理函数的执行，并防止当前事件在DOM树上冒泡。 event.currentTarget：返回绑定事件的元素 event.target：返回触发事件的元素 解释下javascript的冒泡和捕获12345&lt;div id="click1"&gt; &lt;div id="click2"&gt; &lt;div id="click3"&gt;事件&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型。 微软则保持元素3具有优先权，这种事件顺序被称为冒泡型。 W3C选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。 事件监听函数addEventListener()的第三个参数就是控制方法是捕获还是冒泡 js延迟加载的方式有哪些 将script节点放置在最后&lt;/body&gt;之前 使用script标签的defer和async属性，defer属性为延迟加载，是在页面渲染完成之后再进行加载的，而async属性则是和文档并行加载 通过监听onload事件，动态添加script节点创建DOM元素（用得最多） 通过ajax下载js脚本，动态添加script节点 window.onload和DOMContentLoaded的区别123456window.addEventListener('load',function()&#123; //页面的全部资源加载完才会执行，包括图片、视频等&#125;)document.addEventListener('DOMContentLoaded',function()&#123; //DOM渲染完即可执行，此时图片、视频还可能没有加载完&#125;) 如何解决跨域问题 JSONP（JSON with Padding），填充式JSON iframe跨域 HTML5的window.postMessage方法跨域 通过设置img的src属性，进行跨域请求 跨域资源共享（CORS），服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求 哪些操作会造成内存泄漏 当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在IE中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄露。 在IE中，如果循环引用中的任何对象是 DOM 节点或者 ActiveX 对象，垃圾收集系统则不会处理。 闭包可以维持函数内局部变量，使其得不到释放。 在销毁对象的时候，要遍历属性中属性，依次删除，否则会泄漏。 JavaScript中的变量声明提升 函数声明和变量声明总是被JavaScript解释器隐式地提升到包含他们的作用域的最顶端。 function优先声明于var。 函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。 123456789101112131415function foo() &#123; bar(); var x = 1;&#125;function foo() &#123;//等同于 var x; bar(); x = 1;&#125;function test() &#123; foo(); // TypeError "foo is not a function" bar(); // "this will run!" var foo = function () &#123; &#125;// 函数表达式被赋值给变量'foo' function bar() &#123; &#125;// 名为'bar'的函数声明&#125; JavaScript原型和原型链 原型： 原型是一个对象，其他对象可以通过它实现属性继承。 一个对象的真正原型是被对象内部的[[Prototype]]属性(property)所持有。浏览器支持非标准的访问器proto。 在javascript中，一个对象就是任何无序键值对的集合，如果它不是一个主数据类型(undefined，null，boolean，number，string)，那它就是一个对象。 原型链： 因为每个对象和原型都有一个原型(注:原型也是一个对象)，对象的原型指向对象的父，而父的原型又指向父的父，我们把这种通过原型层层连接起来的关系称为原型链。 这条链的末端一般总是默认的对象原型。 JavaScript中的作用域和作用域链 变量的作用域（scope）：程序源代码中定义这个变量的区域。 作用域链：是一个对象列表或链表，这组对象定义了这段代码“作用域中”的变量。查找变量会从第一个对象开始查找，有则用，无则查找链上的下一个对象。 jQuery源码以及jQuery的实现原理 jQuery给我们带来了一个简洁方便的编码模型(1&gt;创建jQuery对象;2&gt;直接使用jQuery对象的属性/方法/事件), 一个强悍的dom元素查找器($)，插件式编程接口(jQuery.fn)，以及插件初始化的”配置”对象思想 jQuery的特点 一款轻量级的js库 丰富快速的DOM选择器 链式表达式 事件、样式、动画等特效支持 Ajax操作封装，支持跨域 跨浏览器兼容 插件扩展开发 浏览器的内核分别是什么 IE: trident内核 Firefox：gecko内核 Safari：webkit内核 Opera：以前是presto内核，现已改用Google Chrome的Blink内核 Chrome：Blink(基于webkit，Google与Opera Software共同开发) 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同，解决方案是加一个全局的*{margin:0;padding:0;}来统一 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 网站重构的理解 重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化，针对于SEO进行优化 减少代码间的耦合，让代码保持弹性 压缩或合并JS、CSS、image等前端资源 WEB应用从服务器主动推送Data到客户端有那些方式 Html5 websoket WebSocket 通过 Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe &lt;script&gt;标签的长时间连接(可跨域) 如何实现浏览器内多个标签页之间的通信 WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； webSocket如何兼容低浏览器？ Adobe Flash Socket ； ActiveX HTMLFile (IE) ； 基于 multipart 编码发送 XHR； 基于长轮询的 XHR。 输入完网址按下回车到看到网页这个过程中发生了什么 域名解析 发起TCP的3次握手 建立TCP连接后发起http请求 服务器端响应http请求，浏览器得到html代码 浏览器解析html代码，并请求html代码中的资源 浏览器对页面进行渲染呈现给用户 关于前端性能优化 请求优化：合并JS和CSS，减少DNS查找次数，避免重定向，使用GET完成AJAX请求，减小请求中的Cookie，缓存资源，使用CDN，开启GZip，压缩HTML页面，开启长连接，避免行内脚本阻塞并行下载，少用iframe（阻塞onload事件，影响并行下载）。 CSS优化：样式表置于页面顶部，避免使用CSS表达式，使用外部JS和CSS，压缩JS和CSS，避免滤镜。 JavaScript优化：脚本置于页面底部，减少DOM访问，减少重绘和重排，尽量使用局部变量，使用定时器分割大型任务，用合适的正则操作字符串，惰性模式减少分支，事件委托，第三方代码异步加载，节流与去抖动，使用localStorage替代cookie。 图片优化：内联图使用Data:URL，压缩图片或使用WebP格式，固定图片尺寸，图片预加载，图片延迟加载，使用字体矢量图标，Sprites图片。 减少页面加载时间的方法 尽量减少页面中重复的HTTP请求数量 服务器开启gzip压缩 css样式的定义放置在文件头部 Javascript脚本放在文件末尾 压缩合并Javascript、CSS代码 使用多域名负载网页内的多个文件、图片 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。 图片懒加载，滚动到相应位置才加载图片。 图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。 使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。 浏览器本地存储 sessionStorage：用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，是会话级别的存储。 localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Cookie的大小是受限的； 每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽； cookie还需要指定作用域，不可以跨域调用； Web Storage拥有setItem,getItem等方法，cookie需要前端开发者自己封装setCookie，getCookie； Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生； IE7、IE6中的UserData通过简单的代码封装可以统一到所有的浏览器都支持web storage； 请求服务器时的状态码。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败 常见的有： 200 OK 客户端请求成功表示成功访问,为网站可正常访问时的状态。 301 Moved Permanently 永久重定向对搜索引擎相对友好的跳转方式，当网站更换域名时可将原域名作301永久重定向到新域名，原域名权重可传递到新域名，也常有将不含www的域名301跳转到含www的，如xxx.com通过301跳转到www.xxx.com 302 Moved Temporarily 临时重定向易被搜索引擎判为作弊,比如asp程序的response.Redirect()跳转、js跳转或静态http跳转。 400 Bad Request 请求错误由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 未授权请求未经授权，无法访问。 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。你的IP被列入黑名单，连接的用户过多，可以过后再试，网站域名解析到了空间，但空间未绑定此域名等情况。 404 Not Found 文件或目录不存在表示请求文件、目录不存在或删除，设置404错误页时需确保返回值为404。常有因为404错误页设置不当导致不存在的网页返回的不是404而导致搜索引擎降权。 500 Internal Server Error 程序或服务器错误表示服务器内部程序错误，出现这样的提示一般是程序页面中出现错误，如小的语法错误，数据连接故障等。 503 Service Unavailable 服务器当前不能够处理客户端的请求在一段时间之后，服务器可能会恢复正常。]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>interview</tag>
        <tag>http</tag>
        <tag>jquery</tag>
        <tag>面试</tag>
        <tag>盒模型</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript正则表达学习]]></title>
    <url>%2F2017%2F05%2F24%2FJavascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是正则表达式正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式，搜索模式可用于文本搜索和文本替换。 正则表达式的语法 /主体/修饰符(可选) 其中，第一个“/“是这个正则表达式的头部,主体是我们想要匹配的模式,第二个“/“是这个正则表达式的尾部，修饰符有三个： i（intensity）：大小写不敏感； g（global）：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行； m（multiple）：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用。 正则表达式的常用方法 test( ) : 在字符串中查找符合正则的内容，若查找到返回true,反之返回false。用法：正则.test(字符串) 123456789// 测试是否是数字：var str = '374829348791';var re = /\D/; // \D代表非数字if( re.test(str) )&#123; // 返回true,代表在字符串中找到了非数字。 console.log('不全是数字');&#125;else&#123; console.log('全是数字');&#125; search( ) ：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回-1。用法：字符串.search(正则) 123456// 在字符串中找字母b，且不区分大小写：var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i'); 也可以这样写console.log( str.search(re) ); // 1 match( ) : 在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： 字符串.match(正则)量词：+ 至少出现一次 匹配不确定的次数（匹配就是搜索查找的意思）。 12345//找出指定格式的所有数字，如下找到 123，54，33，879var str = 'haj123sdk54hask33dkhalsd879';var re = /\d+/g; // 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，有了加号，每次匹配的数字就是至少一个了。console.log( str.match(re) ); // [123，54，33，879] match方法也会返回自己的子项，如下： 12345// 当match不加g的时候才可以获取到子项的集合:var str = 'abc';var re = /(a)(b)(c)/;console.log( str.match(re) ); //[abc,a,b,c](返回的是匹配结果,以及每个子项) replace() :查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： 字符串.replace(正则,新的字符串/回调函数)（在回调函数中，第一个参数指的是每次匹配成功的字符） 12345678910111213141516171819202122//敏感词过滤，比如 我爱北京天安门，天安门上太阳升。------我爱*****，****上太阳升。即北京和天安门变成*号。~~//一开始我们可能会想到这样的方法：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,'*'); console.log(str2) //我爱**，*上太阳升 //这种只是把找到的变成了一个*，并不能几个字就对应几个*。~~//要想实现几个字对应几个*，我们可以用回调函数实现：var str = "我爱北京天安门，天安门上太阳升。";var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re,function(str)&#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; //所以搜索到了几个字就返回几个* &#125;);console.log(str2) //我爱*****，***上太阳升 //整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 正则表达式中的字符 ^ : 正则的最开始位置，就代表起始的意思。注意：/[ ^ a] / 和 / ^ [a]/ 是不一样的，前者是排除的意思，后者是代表首位。 eg:”^ The”–表示所有以”The”开始的字符串（”There”，”The cat”等）; 1234567// 判断是不是QQ号:// 首先想QQ号的规则：1.首位不能是0 ；2.必须是 5-12位的数字。 var str = '1445427773';var re = /^[1-9]\d&#123;4,11&#125;$/;console.log( re.match(str) ); $ : 正则的最后位置，就代表结束的意思。eg:”of despair$”–表示所以以”of despair”结尾的字符串; 12345678910// 去掉前后空格（面试题经常出现）:function trim(str)&#123; var re = /^\s+|\s+$/g; // |代表或者 \s代表空格 +至少一个 前面有至少一个空格 或者后面有至少一个空格 且全局匹配 return str.replace(re,''); //把空格替换成空&#125;var str = ' hello ';console.log('('+str+')');console.log( '('+trim(str)+')' ); //为了看出区别所以加的括号。 ( ) : 小括号，叫做分组符。就相当于数学里面的括号。如下： 12345678var str = '2013-6-7';var re1 = /\d-+/g; // 全局匹配数字，横杠，横杠数量至少为1，匹配结果为： 3- 6-var re2 = /(\d-)+/g; // 全局匹配数字，横杠，数字和横杠整体数量至少为1 3-6-var re3 = /(\d+)(-)/g; // 全局匹配至少一个数字，匹配一个横杠 匹配结果：2013- 6-console.log(str.match(re1));console.log(str.match(re2));console.log(str.match(re3)); 同时，正则中的每一个带小括号的项，都叫做这个正则的子项。子项在某些时候非常的有用，比如下面这个例子： 123456789101112131415// 让2013-6-7 变成 2013.6.7：var str = '2013-6-7';var re = /(\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; // replace()中如果有子项， // 第一个参数：$0（匹配成功后的整体结果 2013- 6-）, // 第二个参数 : $1(匹配成功的第一个分组，这里指的是\d 2013, 6) // 第三个参数 : $1(匹配成功的第二个分组，这里指的是- - - ) return $1 + '.'; // 分别返回2013. 6. &#125;);console.log( str ); // 整个过程就是利用子项把2013- 6- 分别替换成了2013. 6. 最终弹出2013.6.7 转义字符: \s : 空格 \S : 非空格 \d : 数字 \D : 非数字 \w : 字符 ( 字母 ，数字，下划线_ ) \W : 非字符 .（点）: 任意字符 . : 真正的点 \b : 独立的部分 （ 起始，结束，空格 ） \B : 非独立的部分 1234567var str1 = 'onetwo';var str2 ="one two";var re = /one\b/; // e后面必须是独立的 可以是起始，空格，或结束console.log( re.test(str1) ); // falseconsole.log( re.test(str2) ); // true 量词：代表出现的次数。 {n,m} : 至少出现n次，最多m次;“ab{3,5}”：表示一个字符串有一个a跟着3到5个b;“ab{2,}”：表示一个字符串有一个a跟着至少2个b; {n,} : 至少n次; * : 任意次,相当于{0,};“ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； ？：零次或一次,相当于{0,1};“ab?”：表示一个字符串有一个a后面跟着零个或者一个b; + ：一次或任意次,相当于 {1,};“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多; {n} ：正好n次;“ab{2}”：表示一个字符串有一个a跟着2个b（”abb”). [ ]： 表示某个集合中的任意一个。方括号表示某些字符允许在一个字符串中的某一特定位置出现。“[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”);“[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”);“ ^ [a-zA-Z]”：表示一个以字母开头的字符串;“[0-9]%”：表示一个百分号前有一位的数字;“, [a-zA-Z0-9] \$ “ ：表示一个字符串以一个逗号后面跟着一个字母或数字结束。你也可以在方括号里用’ ^ ‘表示不希望出现的字符，’ ^ ‘应在方括号里的第一位。（如：”%[ ^ a-zA-Z]%”表示两个百分号中不应该出现字母)。为了逐字表达，你必须在” ^ .$ ( ) ¦ * + ? { \ “这些字符前加上转移字符’ \ ‘。请注意在方括号中，不需要转义字符。 12345// 匹配HTML标签 比如&lt;div class="b"&gt;hahahah &lt;/div&gt; 找出标签&lt;div class="b"&gt;&lt;/div&gt;var re = /&lt;[^&gt;]+&gt;/g; //匹配左括号 中间至少一个非右括号的内容(因为标签里面还有属性等一些东西)，然后匹配右括号var re = /&lt;[\w\W]+&gt;/g; //匹配左括号 中间至少一个字符或者非字符的内容，然后匹配右括号// 其实就是找到左括号，然后中间可以有至少一个内容，一直到找到右括号就代表是一个标签。 \a ：表示重复的某个子项。比如： \1 : 重复的第一个子项; \2 : 重复的第二个子项; 12/ (a) (b) (c) \1/ // 匹配 abca/ (a) (b) (c) \2/ // 匹配 abcb 12345678910111213141516171819202122// 找重复项最多的字符个数(面试题中经常问到）:var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split(''); // 把字符串转换为数组str = arr.sort().join(''); // 首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串console.log(str); // aaddjjkklsssssssssssssssssvar value = '';var index = 0; var re = /(\w)\1+/g; // 匹配字符，且重复这个字符，重复次数至少一次。str.replace(re,function($0,$1)&#123; // alert($0); 代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss // alert($1); 代表每次匹配成功的第一个子项，也就是\w: a d j k l S if(index&lt;$0.length)&#123; // 如果index保存的值小于$0的长度就进行下面的操作 index = $0.length; // 这样index一直保存的就在最大的长度 value = $1; // value保存的是出现最多的这个字符 &#125;&#125;); console.log('最多的字符:'+value+',重复的次数:'+index); // s 17 split( ):字符串中的方法，把字符串转成数组。sort( ):数组中的排序方法，按照ACALL码进行排序。join( ):数组中的方法，把数组转换为字符串 常用的一些正则表达式 校验是否全由数字组成（[0-9]中的字符出现次数的范围是1到20次): /\^[0-9]{1,20}$ / 校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串: /\^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$ / 校验用户姓名：只能输入1-30个以字母开头的字串: /\^[a-zA-Z]{1,30}$/ 校验密码：只能输入6-20个字母、数字、下划线: /\^(\w){6,20}$/ 校验普通电话、传真号码：可以“+”或数字开头，可含有”-“ 和 “ “ /\^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/ 校验URL: /\^http[s]{0,1}:\/\/.+$/ 校验身份证： /[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x/ 校验Email(起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。)： /\^\w+@[a-z0-9]+(.[a-z]+){1,3}$ /]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个测试颜色辨识度的小游戏]]></title>
    <url>%2F2017%2F05%2F18%2F%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E8%BE%A8%E8%AF%86%E5%BA%A6%E7%9A%84%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[testColorResolution A small game that can test your eyes for color recognition 简介之前有段时间网上有一个挺流行的小游戏叫做“看你有多色”。然后我看了网上的教程用createJS仿写了一个，具体实现后效果如下： 游戏开始 点击与其它方块颜色不一样的方块 一定步数之后，方块数量达到9*9后不再增加 以下是部分关键代码12345678910111213141516171819202122232425262728293031323334353637383940414243var stage = new createjs.Stage("gameView");createjs.Ticker.setFPS(30);createjs.Ticker.addEventListener("tick",stage);var gameView = new createjs.Container();stage.addChild(gameView);var n = 2;function addRect()&#123; var cl = parseInt(Math.random()*1000000); var color = "#" + cl; var cl1 = cl+90000; var RectColor = "#" + cl1; var x = parseInt(Math.random()*n); var y = parseInt(Math.random()*n); for(var indexX = 0;indexX &lt; n ;indexX++)&#123; for(var indexY = 0;indexY &lt; n;indexY++)&#123; var r = new Rect(n,color,RectColor); gameView.addChild(r); r.x = indexX; r.y = indexY; if(r.x == x &amp;&amp; r.y == y)&#123; r.setRectType(2); &#125; r.x = indexX*(400/n); r.y = indexY*(400/n); if(r.getRectType() == 2)&#123; r.addEventListener("click",function()&#123; var audio = document.getElementById("clickSound"); audio.play(); if(n&lt;9)&#123; ++n; &#125; gameView.removeAllChildren(); addRect(); &#125;) &#125; &#125; &#125;&#125;addRect(); 表示颜色的时候用的十六进制而不是RGB，然后随机颜色用的是random函数。而唯一一个不同于其他方块的方块颜色是要比其他颜色浅一些的。点击其他方块没有任何特效，点击唯一正确的方块会进入下一关并且伴随有音效提示，同时整个游戏会有BGM。 源码地址：https://github.com/1996szw/testColorRecognition]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>game</tag>
        <tag>relax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的回流与重绘]]></title>
    <url>%2F2017%2F04%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[Info: 一句话概括就是，回流必将引起重绘，重绘不一定会引起回流。 写在前面在讨论回流与重绘之前，我们需要知道： 浏览器使用流式布局模型 (Flow Based Layout)。 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 回流 (Reflow)当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 重绘 (Repaint)当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 性能代价回流比重绘的代价要更高。 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免CSS 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 Javascript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>回流</tag>
        <tag>重绘</tag>
        <tag>render tree</tag>
        <tag>reflow</tag>
        <tag>repaint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP的三次握手和四次挥手]]></title>
    <url>%2F2017%2F04%2F02%2F%E5%85%B3%E4%BA%8ETCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1.TCP报文格式 几个重点字段： （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： （A）URG：紧急指针（urgent pointer）有效。 （B）ACK：确认序号有效。 （C）PSH：接收方应该尽快将这个报文交给应用层。 （D）RST：重置连接。 （E）SYN：发起一个新连接。 （F）FIN：释放一个连接。 需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 2.三次握手 TCP(Transmission Control Protocol)即传输控制协议，TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 位码即tcp标志位,有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) Sequence number(顺序号码)Acknowledge number(确认号码)establish 建立，创建 所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。SYN攻击： 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： netstat -nap | grep SYN_RECV 3.四次挥手所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。 4.问答1.为什么建立连接是三次握手，而关闭连接却是四次挥手呢？答：这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 2.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>http</tag>
        <tag>tcp</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现垂直水平居中]]></title>
    <url>%2F2017%2F03%2F18%2FCSS%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[CSS实现垂直水平居中 第一种方法（position:absolute，负margin法） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的左外边距、上外边距为宽高的负1/2--&gt;margin-left:-100px;margin-top:-200px;&#125; 优点：兼容性好；缺点：必须固定元素的宽高 第二种方法（使用css3的新属性transform:translate(x,y)） 123456789101112131415div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、左都为50%--&gt;left:50%;top:50%;&lt;!--设置元素的相对于自身的偏移度为负50%(也就是元素自身尺寸的一半)--&gt;transform:translate(-50%,-50%);&#125; 这是css3里的样式，在移动端用得较多；缺点：兼容性不好，只支持IE9+的浏览器。 第三种方法（设置margin为auto） 1234567891011121314151617div.box&#123;weight:200px;height:400px;&lt;!--把元素变成定位元素--&gt;position:absolute;&lt;!--设置元素的定位位置，距离上、下、左、右都为0--&gt;left:0;right:0;top:0;bottom:0;&lt;!--设置元素的margin样式值为 auto--&gt;margin:auto;&#125; 优点：兼容性较好；缺点：不支持IE7以下的浏览器。 第四种方法（inline-block方法） 场景： 一个块状元素A内 有若干个块状元素B，要达到的效果是 ，所有块状元素B 在 元素A 内水平居中显示。 12345&lt;div class="A"&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="B"&gt;&lt;/div&gt;&lt;/div&gt; 首先，我们要设置元素A的大小为500px，设置背景色为green方便查看。 1234.A｛ width:500px; backgrond-color:green;｝ 然后， 设置所有元素B 的宽度为100px，高度为100px，外边据都为5px，背景色为#000方便查看。 123456.B｛ width:100px; height:100px; magin:5px; backgrond-color:green;｝ 此时的效果： 我们要做的是，先把所有的元素B都设置为行内块级元素，让他们都排成一行，即使用：display:inline-block； 最后就是让所有的元素B居中了， 到这里，相信很多人就猜到下一步要做什么了，我锦上添花，解释一下。 先想一想，如果是行内元素， 我们一般让它怎么居中呢？答：当然是给它的父容器加一个text-align:center的样式。 这里我们已经把所有的元素B变成了行内块， 也就有了行内元素的特性，所以，我们下一步要做的就是给元素A加text-align:center， 这样我们的目的就达到了，请看效果： 优点：兼容性较好；缺点：父元素和子元素的宽度都要已知。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>study</tag>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局语法教程]]></title>
    <url>%2F2017%2F03%2F14%2FFlex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Info: Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 网页布局（layout）是CSS的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C提出了一种新的方案—-Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex布局将成为未来布局的首选方案。本文介绍Flex布局的语法。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局: 123.box&#123; display: flex;&#125; 行内元素也可以使用Flex布局: 123.box&#123; display: inline-flex;&#125; Webkit内核的浏览器，必须加上-webkit前缀: 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end`。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性以下6个属性设置在容器上。 123456flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）: 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 1234row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行: 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行: wrap：换行，第一行在上方: wrap-reverse：换行，第一行在下方: flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap: 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式: 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: 12345flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用: 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值: 123456flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 123456orderflex-growflex-shrinkflex-basisflexalign-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0: 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大: 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小: 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小: 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选: 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS经典布局问题整理]]></title>
    <url>%2F2017%2F03%2F14%2FCSS%20%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Info: CSS布局相关。 CSS基础知识 MDN-CSS入门教程： MDN的官方文档 学习CSS布局： 排版不错，简短精悍 CSS定位问题主要就是经典的绝对定位、相对定位问题 10个文档学布局： 通过十个例子讲解布局，主要涉及相对布局，绝对布局，浮动。 百度前端学院笔记 - 理解绝对定位： 文章本身一般，几篇参考文献比较详细 HTML和CSS高级指南之二——定位详解： 介绍浮动的使用，详细介绍定位的技巧，包括如何准确的给元素在 X 轴、Y 轴和 Z 轴定位 三栏式布局涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局圣杯：父盒子包含三个子盒子（左，中，右） 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 .left {margin-left:-100%;} 把左边的盒子拉上去 .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去 父盒子设置左右的 padding 来为左右盒子留位置 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖 1234567&lt;!-- 圣杯的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 双飞翼布局双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。 中间盒子的宽度设置为 width: 100%; 独占一行 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置 123456789&lt;!-- 双飞翼的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class="middle"&gt; &lt;div class="middle-inner"&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 圣杯和双飞翼异同圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。 主要区别在于 如何使中间盒子的内容不被左右盒子遮挡： 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。 利用浮动实现我自己使用浮动也实现了三栏式布局：左边盒子左浮动，右边盒子右浮动，中间盒子利用 margin-left 和 margin-right 来为左右盒子留位置，同时父盒子设置 overflow: auto; 来避免子盒子溢出。 1234567&lt;!-- 浮动实现的 HTML 结构 --&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;左边栏&lt;/div&gt; &lt;div class="right"&gt;右边栏&lt;/div&gt; &lt;!-- 中间的 div 必须写在最后面 --&gt; &lt;div class="middle"&gt;中间弹性区&lt;/div&gt;&lt;/div&gt; 三栏式布局参考下面几个链接: CSS三栏布局——中间固定两边自适应宽度： w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽 简书 - 圣杯布局和双飞翼布局(前端面试必看)：只讲了圣杯，不过特别详细 In Search of the Holy Grail：圣杯布局的来源 百度前端学院笔记 - 三栏式布局之双飞翼与圣杯：百度前端学院学员的前端学习笔记 三栏式布局涉及到负 magin 和 清除浮动的问题。 负magin 负margin用法权威指南：The Definitive Guide to Using Negative Margins 的译文,介绍了负 magin 的一些性质和很多实用技巧 简书 - margin为负值产生的影响和常见布局应用：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高) 博客园 - CSS布局奇淫巧计之-强大的负边距：和上文内容差不多 简单总结几点： 不使用 float 的话，负 margin 元素是不会破坏页面的文档流。所以如果你使用负 margin 上移一个元素，所有跟随的元素都会被上移(而 relative 定位的元素则不同，会保留原位置，影响文档流) 当 static 元素的 margin-top/margin-left 被赋予负值时，元素将被拉进指定的方向 如果你设置 margin-bottom/right 为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素 当元素不存在 width 属性或者 width: auto 的时候，负 margin 会增加元素的宽度 margin-top 为负值不会增加高度，只会产生向上位移;margin-bottom 为负值不会产生位移，会减少自身的供 CSS 读取的高度，影响下方的元素位置；上下相邻的元素两者均为负时，效果不叠加，取负值更多的那个效果 清除浮动清除浮动主要是为了解决高度塌陷问题。而简单的 clear: both 并不能解决这个问题，所以引出了许多解决方案。 StackOverflow - What methods of ‘clearfix’ can I use?：清除浮动黑科技完整解读 那些年我们一起清除过的浮动：神文，把“清除浮动”定义为“闭合浮动”，把问题由来和解决方案都讲清楚了，并且分析了各种解决方案的优劣。 各种解决方案在上面的链接里有很详细的说明了，这里就不赘述了。大体分为两类： 其一，通过在浮动元素的末尾添加一个空元素，设置 clear: both 属性，after 伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素 其二，通过设置父元素 overflow 或者 display: table 属性来闭合浮动 顺便补充一句，clear float(例如 clear: left) 是对某个元素设置，以避免其某一边有浮动元素，即对当前元素产生约束，约束的边界为其他的浮动元素。对于已经浮动的元素，设置 clear float 是无效的。 居中布局Centering in CSS: A Complete Guide：非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码文章大致结构： 1 水平居中 对于行内元素(inline)：text-align: center 对于块级元素(block)：设置宽度且 marigin-left 和 margin-right 是设成 auto 对于多个块级元素：对父元素设置 text-align: center;，对子元素设置 display: inline-block;；或者使用 flex 布局 2 垂直居中 对于行内元素(inline) 单行：设置上下 pandding 相等；或者设置 line-height 和 height 相等 多行：设置上下 pandding 相等；或者设置 display: table-cell; 和 vertical-align: middle;；或者使用 flex 布局；或者使用伪元素 对于块级元素(block)：下面前两种方案，父元素需使用相对布局 已知高度：子元素使用绝对布局 top: 50%;，再用负的 margin-top 把子元素往上拉一半的高度 未知高度：子元素使用绝对布局 position: absolute; top: 50%; transform: translateY(-50%) 使用 Flexbox：选择方向，justify-content: center 3 水平垂直居中 定高定宽：先用绝对布局 top: 50%; left: 50%;，再用和宽高的一半相等的负 margin 把子元素回拉 高度和宽度未知：先用绝对布局 top: 50%; left: 50%;，再设置 transform: translate(-50%, -50%) 使用 Flexbox：justify-content: center; align-items: center 响应式设计响应式设计（Responsive Design) 是一种让网站针对不同的浏览器和设备呈现不同显示效果的策略。 媒体查询(Media Queries)是做此事所需的最强大的工具。 注： Responsive Web Design ＝ RWD，Adaptive Web Design ＝ AWD RWD： 采用 CSS 的 media query 技术 流体布局（fluid grids） 自适应的图片/视频等资源素材（为小、中、大屏幕做一些优化，目的是让任何尺寸的屏幕空间都能得到充分利用） AWD： CSS media query 技术（仅针对有限几种预设的屏幕尺寸设计） 用 JavaScript 来操作 HTML 内容 在服务器端操作 HTML 内容（比如为移动端减少内容，为桌面端提供更多内容） 可以参考 Bootstrap 的网格系统：http://getbootstrap.com/css/#grid-less The Bootstrap 3 grid system has four tiers of classes: xs (phones), sm (tablets), md (desktops), and lg (larger desktops). 自己实现网格系统： Creating Your Own CSS Grid System Flexbox布局点我参考本博客另一篇文章。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>study</tag>
        <tag>position</tag>
        <tag>absolute</tag>
        <tag>relative</tag>
        <tag>flex</tag>
        <tag>float</tag>
        <tag>margin</tag>
        <tag>center</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的DOM对象学习]]></title>
    <url>%2F2017%2F03%2F12%2FJavascript%E4%B8%AD%E7%9A%84DOM%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[DOM 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 先来看看下面代码:12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html"; charset="gb2312"&gt;&lt;title&gt;DOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;&lt;a href="http://www.imooc.com"&gt;javascript DOM&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除CSS样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 将HTML代码分解为DOM节点层次图: HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签。 文本节点:向用户展示的内容，如&lt;li&gt;…&lt;/li&gt;中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如&lt;a&gt;标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: 以上图ul为例，它的父级节点body,它的子节点3个li,它的兄弟结点h2、P。 DOM操作（DOM常见的API）: 注意:前两个是document方法。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>dom</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeCodeCamp上面的JS算法题]]></title>
    <url>%2F2017%2F03%2F11%2FFreeCodeCamp%E4%B8%8A%E9%9D%A2%E7%9A%84JS%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Info:Javascript中操作字符串和数组一些常见的方法。 Split Strings with split()12345var string = "Split me into an array";var array = [];array = string.split(" ");console.log(array); //[ 'Split', 'me', 'into', 'an', 'array' ] // split() 方法用于把一个字符串分割成字符串数组。// 提示： 如果把空字符串 (“ “) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。// 注意： split() 方法不改变原始字符串。 Get the sub string with substring/substr/slice()1234567891011var s = 'hello, world'var r1 = s.substring(0, 5); // 从索引0开始到5(不包括5)var r2 = s.substring(7); // 从索引7开始到结束var r3 = s.substr(2,4); //从索引开始找接下来的4个字符var r4 = s.slice(-5);console.log(r1); //helloconsole.log(r2); //worldconsole.log(r3); //llo,console.log(r4); //world Title Case a Sentence with toUpper/LowerCase()12345678910111213141516171819202122// 句中单词首字母大写:function titleCase(str) &#123; // 请把你的代码写在这里 arr = str.split(" "); var newStr = ""; for(var i = 0;i&lt;arr.length;i++)&#123; newStr += arr[i][0].toUpperCase(); for(var j = 1;j&lt;arr[i].length;j++)&#123; newStr += arr[i][j].toLowerCase(); &#125; if(i!=arr.length-1)&#123; newStr += " "; &#125;&#125; return newStr;&#125;var r = titleCase("I'm a little tea pot");console.log(r); //I'm A Little Tea Pot Get the index of string in a stringObj with indexOf/lastIndexOf()123456789var s = 'hello, world';var r1 = s.indexOf('world'); // 找到指定的子串,返回该子串第一次出现的位置var r2 = s.indexOf('sorld'); // 没有找到指定的子串，返回-1var r3 = s.lastIndexOf('l'); // 找到指定的子串，返回该子串最后一次出现的位置console.log(r1); //7console.log(r2); //-1console.log(r3); //10 Iterate over Arrays with map()1234567891011121314151617var oldArray = [1,2,3,4,5];// 只能在这一行下面写代码var newArray = oldArray.map(function(val)&#123; return val + 3;&#125;);console.log(newArray); //[ 4, 5, 6, 7, 8 ]// another// var numbers = [4, 9, 16, 25];// function myFunction() &#123;// x = document.getElementById("demo")// x.innerHTML = numbers.map(Math.sqrt);// &#125; // map() 方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。// map() 方法按照原始数组元素顺序依次处理元素。// 注意： map() 不会对空数组进行检测。// 注意： map() 不会改变原始数组。 Condense arrays with reduce()12345678910var array = [4,5,6,7,8];var singleVal = 0;// 只能在这一行下面写代码singleVal = array.reduce(function(pre,cur)&#123; return pre + cur ;&#125;);console.log(singleVal); //30 // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并(迭代)，最终计算为一个值。// 注意: reduce() 对于空数组是不会执行回调函数的。 Filter Arrays with filter()123456789var oldArray = [1,2,3,4,5,6,7,8,9,10];// 只能在这一行下面写代码var newArray = oldArray.filter(function(val)&#123; return val &lt; 6;&#125;);console.log(newArray); //[ 1, 2, 3, 4, 5 ] // filter 方法用来迭代一个数组，并且按给出的条件过滤出符合的元素。// filter 方法传入一个回调函数，这个回调函数会携带一个参数，参数为当前迭代的项（我们叫它 val ）。// 回调函数返回 true 的项会保留在数组中，返回 false 的项会被过滤出数组。 Sort Arrays with sort()1234567var array = [1, 21, 12, 2];array.sort(function(a, b) &#123; return b - a;&#125;); // 将数组元素从大到小排序console.log(array); //[ 21, 12, 2, 1 ] 1234567891011121314151617// 数组排序并找出元素索引:function where(arr, num) &#123; // 请把你的代码写在这里 var newArr = []; newArr = arr.concat(num); newArr.sort(function(a,b)&#123; return a-b; &#125;); for(var i =0;i&lt;newArr.length;i++)&#123; if(newArr[i] === num)&#123; return i;&#125; &#125;&#125;var r = where([40, 60], 50);console.log(r); //1 // sort() 方法将改变原数组，返回被排序后的数组。// sort() 可以把比较函数作为参数传入。比较函数有返回值，当 a 小于 b，返回一个负数；当 a 大于 b ，返回一个正数；相等时返回0。// 如果没有传入比较函数，它将把值全部转成字符串，并按照字母顺序进行排序。 Reverse Arrays with reverse()12345678var array = [1,2,3,4,5,6,7];var newArray = [];// 只能在这一行下面写代码newArray = array.reverse();console.log(newArray); //[ 7, 6, 5, 4, 3, 2, 1 ] // reverse()方法用于颠倒数组中元素的顺序。// reverse()方法会改变原来的数组，而不会创建新的数组。 Concatenate Arrays with concat()12345678var oldArray = [1,2,3];var newArray = [];var concatMe = [4,5,6];newArray = oldArray.concat(concatMe);console.log(newArray); //[ 1, 2, 3, 4, 5, 6 ] // concat()方法用于连接两个或多个数组。// concat()方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 Join Strings with join()12345678var joinMe = ["Split","me","into","an","array"];var joinedString = ' ';// 只能在这一行下面写代码joinedString = joinMe.join(joinedString);console.log(joinedString); //Split me into an array // join() 方法用于把数组中的所有元素转换一个字符串。// 元素是通过指定的分隔符进行分隔的。 Find the Longest Word in a String with Math.max.apply()12345678910111213141516171819// 找到字符串中最长的单词function findLongestWord(str) &#123; var maxLength = 0; var arr = []; var s = str.split(" "); console.log(str); for(var i = 0;i&lt;s.length;i++)&#123; arr[i] = s[i].length; &#125; maxLength = Math.max.apply(null,arr); return maxLength;&#125;var r = findLongestWord("The quick brown fox jumped over the lazy dog");console.log(r); //6 //Math.max.apply()方法可以得到数组中最大的数,Math.max.apply(null,arr)其中第一个参数null，这个是因为没有对象去调用这个方法，所以直接传递null过去。 Remove the smallest number in an array with splice()123456789function removeSmallest(numbers) &#123; if(!numbers)&#123;return []&#125; var min = Math.min.apply(null,numbers); numbers.splice(numbers.indexOf(min),1); return numbers;&#125;var numbers = [2,1,3,4,1,2,5];var s = removeSmallest(numbers);console.log(s); //[ 2, 3, 4, 1, 2, 5 ] //splice()方法:arrayObject.splice(index,howmany,item1,…..,itemX)，实现删除从index处开始的零个或多个(howmany)元素，并且用参数列表中声明的一个或多个值(item1~X)来替换那些被删除的元素。]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>algorithm</tag>
        <tag>freecodecamp</tag>
        <tag>array</tag>
        <tag>string</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【二】]]></title>
    <url>%2F2017%2F03%2F08%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%BA%8C%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:JS学习的补充笔记，包括JS-Web-Api、事件绑定、事件冒泡、事件代理、AJAX、跨域和存储 日期123456789Date.now(); //获取当前时间毫秒数var dt = new Date(); //Date()是一个构造函数，.now是他的一个属性函数dt.getTime(); //获取毫秒数dt.getFullYear(); //年dt.getMonth(); //月（0 - 11）dt.getDate(); //日（0 - 31）dt.getHours(); //小时（0 - 23）dt.getMinutes(); //分钟（0 - 59）dt.getSeconds(); //秒（0 - 59） MathMath.random()获取随机数 数组API forEach 遍历所有元素 every 判断所有元素是否都符合条件 some 判断是否至少有一个元素符合条件 sort 排序 map 对元素重新组装，生成一个新数组 filter 过滤符合条件的元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.forEachvar arr = [1,2,3];arr.forEach( function(item, index) &#123; console.log(index,item);// 0 1 1 2 2 3&#125;);// 2.everyvar arr = [1,2,3];var result = arr.every(function(item,index)&#123; if(item &lt; 4)&#123; return true; &#125;&#125;)console.log(result); // true// 3.somevar arr = [1,2,3];var result = arr.some(function(item,index)&#123; if(item &lt; 2)&#123; return true; &#125;&#125;)console.log(result); //true// 4.sortvar arr = [1,4,3,5,2];var arr2 = arr.sort(function(a,b)&#123; return a - b; //从小到大排序&#125;)console.log(arr2); //[1,2,3,4,5]// 5.mapvar arr = [1,2,3,4];var arr2 = arr.map(function(item,index)&#123; return '&lt;b&gt;' + item + '&lt;/b&gt;';&#125;)console.log(arr2); //[ '&lt;b&gt;1&lt;/b&gt;', '&lt;b&gt;2&lt;/b&gt;', '&lt;b&gt;3&lt;/b&gt;', '&lt;b&gt;4&lt;/b&gt;' ]// 6.filtervar arr = [1,2,3];var arr2 = arr.filter(function(item,index)&#123; //通过某个条件过滤数组 if(item &gt;= 2)&#123; return true; &#125;&#125;)console.log(arr2); //[2,3] 对象API1234567891011var obj = &#123; x: 100, y: 200, z: 300&#125;var key;for (key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key,obj[key]); &#125;&#125; // x 100 y 200 z 300 事件通用事件绑定123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div&gt; &lt;a href="http://baidu.com" id="link1"&gt; &lt;button type="button" id="btn1"&gt;我是按钮&lt;/button&gt; &lt;/a&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById('btn1'); btn.addEventListener('click', function(event)&#123; console.log('clicked'); &#125;) function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var a = document.getElementById('link1'); bindEvent(a,'click', function(e)&#123; e.preventDefault(); //阻止默认行为 alert('clicked'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件冒泡12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;p id="p1"&gt;激活&lt;/p&gt; &lt;p id="p2"&gt;取消&lt;/p&gt; &lt;p id="p3"&gt;取消&lt;/p&gt; &lt;p id="p4"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id="div2"&gt; &lt;p id="p5"&gt;取消&lt;/p&gt; &lt;p id="p6"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; function bindEvent (elem,type,fn) &#123; elem.addEventListener(type, fn); &#125; var p1 = document.getElementById('p1'); var body = document.body; bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); //阻止事件冒泡 alert('激活'); &#125;) bindEvent(body,'click',function(e)&#123; alert('取消'); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代理 （冒泡的应用）它还有一个名字叫事件委托，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li &#123; display: block; height: 50px; width: 100px; text-align: center; line-height: 50px; background-color: #888; margin-bottom: 8px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="Inul"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //不使用事件委托 /*window.onload = function()&#123; var oUL = document.getElementById("Inul"); var aLi = oUL.getElementsByTagName("li"); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125; &#125;*/ //使用事件委托 window.onload = function () &#123; var oUL = document.getElementById("Inul"); oUL.onclick = function () &#123; alert(123); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代理的两个优点：1.使得代码比较简洁2.给浏览器的压力比较小 AJAXAJAX的全称 Asynchronous Javascript And XML 异步JavaScript和XML XMLHttpRequest123456789101112var xhr = new XMLHttpRequest()xhr.open("GET","/api",true)xhr.onreadystatechange = function () &#123; // 第三个参数为true,这里的函数为异步执行 if(xhr.readyState === 4)&#123; if(xhr.status === 200)&#123; alert(xhr.responseText) &#125; &#125;&#125;xhr.send(null) 跨域什么是跨域 可以跨域的三个标签但是有三个标签可以跨域加载资源 &lt;img src = “XXX”&gt; （图片） &lt;link herf = “XXX”&gt; （CSS） &lt;script src = “XXX”&gt; （JS） 这三个标签的场景 &lt;img&gt;用于打点统计，统计网站可能是其他域 &lt;link&gt;&lt;script&gt;可以使用CDN，CDN的也是其他域 &lt;script&gt;可以用于JSONP 跨域注意事项 所有的跨域请求都必须经过信息提供方允许 如果未经允许就能够获取到，那就是浏览器的同源策略出现了漏洞 解决跨域的方法 JSONP JSONP的工作原理： 很简单，就是利用&lt;script&gt;标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个&lt;script&gt;元素，地址指向第三方的API网址，形如：&lt;script src=”http://www.example.net/api?param1=1&amp;param2=2&quot;&gt; &lt;/script&gt;并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。 第三方产生的响应为json数据的包装（故称之为jsonp，即json padding）形如:callback({“name”:”hax”,”gender”:”Male”})。 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。 补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。 服务器端设置 http header（即CORS（跨域资源共享）） 存储 cookie localStorage 和 sessionStorage cookie与webStorage的区别]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>js-web-api</tag>
        <tag>ajax</tag>
        <tag>事件</tag>
        <tag>跨域</tag>
        <tag>cookie</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript学习笔记【一】]]></title>
    <url>%2F2017%2F03%2F06%2FJavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[Info:之前JS学习的一些笔记，包括JS变量类型以及JS的三个重点：原型和原型链、作用域与闭包、异步和单线程 变量类型和计算引用类型（3种）对象、数组、函数。 引用类型的内存只存一份，而值类型是存多份 引用类型可以无限扩展属性 typeof（6种）undefined、number、string、boolean、object、function。 强制类型转换 字符串拼接； ==运算符； if条件语句； 逻辑运算（与或非)。 何时使用==if(obj.a == null){ … } //这里是简写，相当于obj.a === null || obj.a === undefined。其他时候全部用三等“===”。 if(…){ }条件为假的几种情况 0； NaN； “”; null; undefined; false。 JS中的内置函数（数据封装内对象） Object； Array； Boolean； Number； String； Function； Date； RegExp； Error。 如何理解JSON JSON.stringify({a:10,b:20}); // 把对象变成字符串 JSON.parse(‘{“a”:10,”b”:20}’)。 // 把字符串变成对象 （JSON只不过是一个JS对象）上面就是JSON常见的两个API。 原型与原型链构造函数12345678910111213function Foo(name,age)&#123; //构造函数首字母大写 this.name = name; this.age = age; this.class = 'class-1'; //return this; //返回这个对象&#125;var f = new Foo('zhangsan',20);//var f1 = new Foo('lisi',22);console.log(f); //Foo &#123; name: 'zhangsan', age: 20, class: 'class-1' &#125;console.log(f instanceof Object); //true 构造函数—拓展 var a = { } 其实是var a = new Object()的语法糖； var a = [ ] 其实是var a = new Array()的语法糖； function Foo(){…} 其实是var Foo = new Function()的语法糖； 使用instanceof判断一个函数是否是一个变量的构造函数。 原型规则和示例 所有的引用类型（对象、数组、函数）都具有对象特性，即可自由拓展属性（除了”null”之外）； 所有的引用类型（对象、数组、函数）都有一个__proto__（隐式原型）属性，属性值是一个普通的对象； 所有的函数都有一个prototype（显式原型）属性，属性值是一个普通的对象； 所有的引用类型（对象、数组、函数），__proto__属性值指向它的构造函数的prototype属性值； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找。 123456789101112131415//第一条规则：var obj = &#123;&#125;; obj.a = 100;var arr = []; arr.a = 100;function fn()&#123;&#125;; fn.a = 100;//第二条规则：console.log(obj.__proto__); //&#123;&#125;console.log(arr.__proto__); //[]console.log(fn.__proto__); //[Function]//第三条规则：console.log(fn.prototype); //fn &#123;&#125;//第四条规则：console.log(obj.__proto__ === Object.prototype); //true 12345678910111213141516171819202122// 第五条规则：// 构造函数function Foo (name,age) &#123; this.name = name;&#125;Foo.prototype.alertName = function()&#123; alert(this.name);&#125;// 创建示例var f = new Foo('zhangsan');f.printName = function () &#123; console.log(this.name);&#125;// 测试f.printName(); //zhangsanf.alertName(); //zhangsanf.toString(); //要去 f.__proto__.__proto__中去寻找//console.log(f.__proto__.__proto__.__proto__); //null 补充： 12345678var item;for(item in f)&#123; // 虽然高级浏览器已经在 for in 中屏蔽了来自原型的属性 // 但是还是建议加上这个判断，保证程序的健壮性 if(f.hasOwnProperty(item))&#123; console.log(item); &#125;&#125; 原型链 instanceof用于判断引用类型属于那个构造函数的方法。 关于原型和原型链的几个问题1.如何准确判断一个变量是数组类型： 123var arr = [];arr instanceof Array; //truetypeof arr; //Object(typeof是无法准确判断是否是数组的 2.写一个原型链继承的例子： 12345678910111213141516171819202122232425//普通版：// 动物function Animal (name) &#123; this.name = name; this.eat = function () &#123; console.log(this.name + ' eat'); &#125;&#125;// 狗function Dog (name) &#123; this.name = name; this.bark = function () &#123; console.log(this.name + ' bark'); &#125;&#125;//绑定原型，实现继承Dog.prototype = new Animal();// 哈士奇var dog = new Dog("hashiqi");dog.bark()dog.eat() 12345678910111213141516171819202122232425262728293031323334//高级版（写一个封装DOM查询的例子）：function Elem (id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function(val)&#123; var elem = this.elem; if(val)&#123; elem.innerHTML = val; return this; //链式操作 &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function (type,fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem('div1');// console.log(div.html())div1.html('&lt;p&gt;hello world&lt;/p&gt;');div1.on('click',function () &#123; alert('clicked!');&#125;)//因为有第十行的“return this”（返回的是this这个对象），所以可以进行链式操作：// div1.html('&lt;p&gt;hello world&lt;/p&gt;').on('click',function()&#123;// alert('clicked!');// &#125;); 3.描述new一个变量的过程： 即考察对构造函数的理解。 创建一个新对象； this指向这个对象； 执行代码，即对this赋值； 返回this。 4.zepto（或其他框架）源码中如何使用原型链： zepto设计和源码分析 作用域与闭包执行上下文 范围：一段&lt;script&gt;或者一个函数 全局：变量定义、函数声明 （一段&lt;script&gt;） 函数：变量定义、函数声明、this、arguments （一个函数） 123456789console.log(a); //undefinedvar a = 100;fn('zhangsan');function fn (name) &#123; age = 20; console.log(name,age); //zhangsan 20 var age;&#125; this this要在执行时才能确认值，定义时无法确认。 作为构造函数执行； 作为对象属性执行； 作为普通函数执行； call()、apply()、bind()； 1234567891011121314151617181920212223242526272829303132333435363738394041//1.作为构造函数执行function Foo (name) &#123; this.name = name;&#125;var f = new Foo('zhangsan');//2.作为对象属性执行var obj = &#123; name: 'A', printName: function () &#123; console.log(this.name); &#125;&#125;obj.printName(); //A (this ===obj)//3.作为普通函数执行function fn()&#123; console.log(this);&#125;fn(); ///undefined (this === window)//4.call和apply（都用来改变this的值，call在实际工作中用的更多,两者传参方式不一样，apply用数组格式）function fn1(name,age)&#123; alert(name) alert(age) console.log(this)&#125;fn1.call(&#123;x:100&#125;,'zhangsan',22)//bind（同样用来改变this的值，注意函数声明要用函数表达式的方式）var fn2 = function (name,age)&#123; alert(name) alert(age) console.log(this)&#125;.bind(&#123;x:100&#125;)fn2('zhangsan',22) 作用域 JS没有块级作用域； 只有函数和全局作用域； 1234567891011121314// 无块级作用域if(true)&#123; var name = 'zhangsan';&#125; //大括号相当于一个块console.log(name); //zhangsan// 函数和全局作用域var a = 100;function fn () &#123; var a = 200; console.log('fn',a);&#125;fn(); //fn 200console.log('global',a); //global 100 作用域链1234567891011121314var a = 100;function fn1 () &#123; var b =200; function fn2 () &#123; var c = 300; //当前作用域没有定义的变量，即“自由变量”，自由变量要去声明时候的作用域去找，而不是执行时候的作用域 console.log(a); //a是自由变量，则要到当前fn2作用域的父级作用域去找，没有找到，则继续到fn1的父级作用域去找 console.log(b); //b是自由变量，则要到当前fn2作用域的父级作用域去找，即fn1的作用域，找到了 console.log(c); &#125; fn2();&#125;fn1(); //100 200 300 闭包闭包的使用场景 函数作为返回值； 函数作为参数传递； 123456789101112// 1.函数作为返回值： function fn1 () &#123; var a = 100; return function () &#123; // 返回一个函数（函数作为返回值） console.log(a); // 自由变量，父作用域查找 &#125;&#125;// fn1得到一个函数var f1 = fn1();var a = 200;f1(); //100 123456789101112131415// 2.函数作为参数传递function fn1 () &#123; var a = 100; return function () &#123; console.log(a); &#125;&#125;var f1 = fn1();function fn2 (fn) &#123; //函数作为参数传递 var a = 200; fn()&#125;fn2(f1); //100 闭包的示例12345678910111213141516171819202122// 1.查询是否是第一次载入：// 闭包实际应用中主要用于封装变量，收敛权限function isFirstLoad () &#123; var _list = []; return function (id) &#123; if(_list.indexOf(id) &gt;= 0)&#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;&#125;// 使用var firstLoad = isFirstLoad();firstLoad(10); //truefirstLoad(10); //falsefirstLoad(20); //true// 在isFirstLoad函数外面，根本不可能改掉_list的值 123456789101112131415// 2.创建10个a标签，点击弹出相应的序号：var i;for(i = 0;i &lt; 10;i++)&#123; (function (i)&#123; // 自执行函数，就是不用调用，只要定义完成，立刻执行的函数 // 函数作用域 var a = document.createElement('a'); a.innerHTML = i + '&lt;br&gt;'; a.addEventListener('click', function(e)&#123; e.preventDefault(); alert(i); //自由变量，要去父级作用域获取值 &#125;) document.body.appendChild(a); &#125;)(i)&#125; 异步和单线程什么是异步（对比同步）1234567891011// 异步：console.log(100);setTimeout(function()&#123; console.log(200);&#125;,1000)console.log(300); //先打印100，然后打印300，过一秒钟再打印200// 对比同步：console.log(100);alert(200); //程序阻塞在这里，如果不点击确认就会卡在这里console.log(300); 何时需要异步 在可能发生等待的情况； 等待过程中不能像alert一样阻塞程序的执行； 因此，所有“等待的情况”都需要异步； //并非“阻塞的情况” 前端使用异步的场景 定时任务：setTimeout、setInterval； 网络请求：ajax请求、es6中的promise、动态&lt;img&gt;加载； 事件绑定； setTimeout(表达式,延时时间)和setInterval(表达式,延时时间)经常被用来处理延时和定时任务。setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到clearInterval把它清除。 很多人会将setTimeout包含于被执行函数中,然后在函数外再次使用setTimeout来达到定时执行的目的。这样,函数外的setTimeout在执行函数时再次触发setTimeout从而形成周而复始的定时效果； 使用的时候各有各的优势，使用setInterval，需要手动的停止tick触发。而使用方法中嵌套setTimeout，可以根据方法内部本身的逻辑不再调用setTimeout就等于停止了触发。其实两个东西完全可以相互模拟，具体使用那个，看当时的需要而定了。 12345678910111213141516171819202122// ajax请求代码示例：console.log('start');$.get('./datta1.json',function(data1)&#123; console.log(data1);&#125;)console.log('end');// &lt;img&gt;加载示例：console.log('start');var img = document.createElement('img');img.onload = function()&#123; console.log('loaded');&#125;img.src = '/xxx.img';console.log('end');// 事件绑定示例：console.log('start');document.getElementById('btn1').addEventListener('click', function()&#123; alert('clicked');&#125;)console.log('end'); 异步和单线程1234567891011// 单线程：一次只能干一件事，一个一个排队来console.log(100);setTimeout(function()&#123; console.log(200);&#125;)console.log(300);// 1. 执行第一行，打印100；// 2. 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）；// 3. 执行最后一行，打印300；// 4. 待所有的程序执行完，处于空闲状态时，会立马看有没有暂存起来的需要执行；// 5. 发现暂存起来的setTimeout中的函数无需等待时间，就立即拿过来执行； 关于异步和单线程的几个问题 同步和异步的区别是什么。分别举一个同步和异步的例子： 同步会阻塞代码执行，而异步不会； alert是同步，setTimeout是异步。 一个关于setTimeout的笔试题： 12345678910console.log(1);setTimeout(function()&#123; console.log(2)&#125;,0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;,1000);console.log(5);// result: 1 3 5 2 4]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>javascript</tag>
        <tag>异步</tag>
        <tag>JS变量类型</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github Pages搭建个人博客]]></title>
    <url>%2F2017%2F03%2F04%2FGithub-Pages-Hexo%E5%8D%9A%E5%AE%A2-Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天也算是摸爬滚打终于搭建成功了这个Hexo博客，然后也是想把过程记录一下，把整个步骤分享给大家（虽然可能也不会有人看到。。 Hexo本地环境搭建Git环境 首先我们需要一个git环境，MacOS的XCode是自带git的所以也无需重复安装。 如果是Windows用户的话，可以去Git官网根据自己的电脑操作系统位数下载相应的版本，下载完成后点击安装，一路next即可。 Windows用户还需要配置环境变量，具体操作可参考度娘上面的教程：Git的安装与配置 测试是否安装配置成功：win+R打开运行，输入cmd打开命令提示窗口，输入如下命令： git –version 如果正确打印出安装的Git版本号，则说明安装成功。 Node.js环境 Mac用户可以通过Homebrew来安装(推荐)，具体步骤如下： 先安装Homebrew： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 然后更新brew确保其可用： brew update 再安装环境所需的Node.js： brew install node 验证是否安装成功： node -vnpm -v 如果正确打印出安装的Node版本号，则说明安装成功。 Windows用户，可以去Node官网根据自己的操作系统位数下载安装（过程跟上述安装Git的步骤类似，在此不再赘述。。 Hexo环境Hexo是一款基于Node.js的静态博客框架，所以之前的那些步骤都是为了安装hexo所做的准备，具体安装hexo的步骤如下： 选择一个你喜欢的目录，用来存放你的hexo博客的所有文件，在此目录下运行你的Git Bash（Windows直接右键你所选择的目录会有个Git Bash选项，点击即可。Mac用户则是打开你的Terminal工具，cd到你所选择的目录再进行一系列的操作） 正式安装Hexo，输入如下指令： npm install -g hexo-cli 当然由于我国的社会主义核心建设，上述命令可能被墙，从而导致安装失败。此时将命令中的npm镜像源改成国内万能的某宝提供的镜像源即可： sudo npm install -g hexo-cli –registry=https://registry.npm.taobao.org 初始化hexo： hexo init hexo 正确初始化后会得到这样的反馈：INFO Start blogging with Hexo! 安装依赖文件： npm install 部署形成文件： hexo generate(或者 hexo g) 本地测试： hexo server(或者 hexo s) 正确完成到了这一步后，在浏览器输入 http://localhost:4000 后就能看到搭建好的hexo站点了。 接下来的步骤则是将本地的hexo放到github上托管，再重定向到你的个人域名以方便访问。 Github Pages注册Github如果不是程序员的话，可能会没有Github账号，这时就需要去Github官网去注册一个账号。注册成功后记得去你填的那个邮箱查收验证确认邮件。 新建一个仓库（new repository）注册登录成功后，去你的github主页点击”New repository”，取名为 “your_user_name.github.io”。 启用Github Pages 进入版本库后，点击右上方的setting，往下翻到Github Pages，点击Launch automatic page generator。 再然后来到New user site页面后点击右下角的Continue to layouts。 最后点击”Publish page”,发布github默认生成的一个静态站点。此时我们就可以通过在浏览器输入“your_user_name.github.io”来访问你的github站点主页。 将Hexo本地项目托管到GitHub Pages建立关联进入到你的本地hexo博客目录，有个_config.yml文件（全局配置文件），打开它，翻到最后面，将deploy改成如下所示： type: gitrepository: https://github.com/your_user_name/your_user_name.github.io.gitbranch: master 安装hexo-deployer-git插件在你的博客目录下输入如下命令： npm install hexo-deployer-git –save 将本地博客部署到GitHub Pages上依次执行下面三条命令： hexo cleanhexo generator 或 hexo ghexo deploy 或 hexo d 如果得到如下输出： INFO Deploy done: git 则说明部署成功。此时你可以通过在浏览器输入“your_user_name.github.io”来访问到你的hexo博客了。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>share</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F03%2FHello%20World%2F</url>
    <content type="text"><![CDATA[写在开始 阮一峰老师说，喜欢写blog的人，会经历三个阶段。 （1）第一阶段，刚接触blog，觉得很新鲜，试着注册一个免费空间来写。 （2）第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 （3）第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我就是这个样子。本来用的博客园，但总感觉不属于自己，再加上个人对博客园的界面颇有微词，一个偶然间看到了别人的hexo个人网站，觉得简洁的风格很好看也挺geek，于是瞬间倒戈。。 再然后Hexo是一个基于Node.js的静态博客程序，生成的静态网页可以直接放到GitHub Pages上面（ps。顺便还能绿化一下GitHub的Contributions岂不是挺美滋滋？？ 然后我又想到自己之前买过腾讯家的服务器还送了域名，就准备将博客绑定下自己的域名，这样感觉就像是拥有了自己的小窝（虽然一系列的过程也是挺折腾的。。orz 到现在对着别人的“5分钟 就能搭建好免费个人博客”教程，折腾了好几个小时，中间还出现很意外的错误，终于是搞定下来了。。 当通过访问自己的域名看到博客加载下来之后，还是有些喜悦和成就感的。毕竟这也不是QQ空间、不是新浪微博、不是豆瓣小站。它更像是身为码农的我辛辛苦苦分到一块地，加以耕耘后不再需要在地主的土地上创造流量价值，感觉还是非常不错的。。 写在最后虽然感觉这个博客上也不会有什么人一起交流，但认为博客的价值还是在于记录，等你回头看你的博客时，能够让你你看到时光在你身上翻飞的样子。 总之，Hello World ～ 😘]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>note</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
</search>
